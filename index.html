<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Music Billboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Base styles */
      body {
        font-family: 'Inter', sans-serif;
        background-color: #f9fafb;
        /* Lighter gray background */
        min-height: 100vh;
      }

      /* Container styling */
      .content-wrapper {
        width: 95%;
        max-width: 1100px;
        margin: 1rem auto;
        /* Reduced top/bottom margin */
        background-color: white;
        padding: 1rem 1.5rem;
        /* Adjusted padding */
        border-radius: 0.75rem;
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        border: 1px solid #e5e7eb;
      }

      .list-container-wrapper {
        padding: 0;
      }

      .chart-container {
        height: 50vh;
        /* Slightly reduced height */
        position: relative;
        display: none;
        padding: 1rem;
      }

      #top100ListContainer {
        display: none;
        min-height: 50vh;
        padding-top: 0.5rem;
      }

      /* Settings Section */
      #settingsSection {
        display: none;
        max-width: 600px;
        margin: 1.5rem auto;
      }

      #settingsSection h3 {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        text-align: center;
      }

      .setting-item {
        margin-bottom: 1rem;
        display: flex;
        flex-direction: column;
        sm: flex-direction: row;
        align-items: stretch;
        sm: align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        sm: gap: 1rem;
      }

      .setting-item label {
        font-weight: 500;
        color: #374151;
        flex-shrink: 0;
        margin-bottom: 0.25rem;
        sm: margin-bottom: 0;
      }

      .setting-item .input-group {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        justify-content: space-between;
      }

      .setting-item input[type=number],
      .setting-item select {
        padding: 0.4rem 0.6rem;
        border-radius: 0.375rem;
        border: 1px solid #d1d5db;
        background-color: white;
        max-width: 100px;
        flex-grow: 1;
        sm: flex-grow: 0;
      }

      .setting-item input[type=number]:disabled {
        background-color: #f3f4f6;
        cursor: not-allowed;
      }

      /* Style disabled input */
      .settings-actions {
        margin-top: 1.5rem;
        text-align: right;
      }

      /* Drop Zone */
      #dropZone {
        border: 2px dashed #cbd5e1;
        border-radius: 0.5rem;
        padding: 2rem;
        /* Adjusted padding */
        text-align: center;
        cursor: pointer;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }

      #dropZone:hover {
        border-color: #9ca3af;
      }

      #dropZone.dragover {
        background-color: #eef2ff;
        border-color: #a5b4fc;
      }

      #status {
        margin-top: 1rem;
        font-style: italic;
        color: #64748b;
        min-height: 1.5em;
      }

      /* Buttons & Inputs - Refined */
      button,
      .button {
        background-color: #4f46e5;
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
        border: none;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.2s ease;
        margin: 0.25rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        white-space: nowrap;
        /* Prevent button text wrap */
      }

      button:hover,
      .button:hover {
        background-color: #4338ca;
        transform: translateY(-1px);
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      }

      button:active,
      .button:active {
        transform: translateY(0px);
        box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
      }

      button:disabled,
      .button:disabled {
        background-color: #a5b4fc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
        opacity: 0.7;
      }

      select,
      input[type="date"],
      input[type="text"] {
        padding: 0.5rem 0.75rem;
        border-radius: 0.375rem;
        border: 1px solid #d1d5db;
        margin: 0.25rem;
        background-color: white;
        box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        width: 100%;
        /* Full width on mobile */
        max-width: none;
        /* Override previous max-width */
      }

      input[type="date"] {
        height: calc(1rem + 1rem + 2px);
      }

      /* Match button height */
      /* Specific widths for larger screens */
      @media (min-width: 640px) {

        select,
        input[type="date"],
        input[type="text"] {
          width: auto;
        }

        #searchInput {
          width: 100%;
        }

        /* Keep search full width */
      }


      /* Search & Suggestions */
      #searchContainer {
        position: relative;
        margin: 0 auto 1rem auto;
        max-width: 500px;
        width: 100%;
      }

      /* Full width */
      #suggestions {
        position: absolute;
        background-color: white;
        border: 1px solid #e5e7eb;
        border-top: none;
        border-radius: 0 0 0.5rem 0.5rem;
        width: 100%;
        max-height: 300px;
        /* Increased height */
        overflow-y: auto;
        z-index: 10;
        box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
      }

      #suggestions div {
        padding: 0.6rem 0.8rem;
        cursor: pointer;
        font-size: 0.9rem;
      }

      #suggestions div:hover {
        background-color: #f3f4f6;
      }

      .suggestion-type {
        font-weight: 600;
        color: #4f46e5;
        margin-right: 0.5rem;
        font-size: 0.8rem;
      }

      .suggestion-artist {
        color: #6b7280;
        font-size: 0.85rem;
        margin-left: 0.3rem;
      }

      /* Controls Area - Responsive */
      .controls-area {
        display: grid;
        grid-template-columns: 1fr;
        /* Stack vertically by default */
        gap: 0.75rem;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #e5e7eb;
      }

      /* Adjust layout for medium screens and up */
      @media (min-width: 768px) {
        .controls-area {
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          /* More flexible grid */
          justify-content: center;
          align-items: center;
          gap: 0.75rem 1.5rem;
        }

        /* Group week nav and jump together */
        #weekNavContainer,
        #jumpToWeekContainer {
          justify-content: center;
        }
      }

      /* Ensure buttons don't take full width unless needed */
      .controls-area>div {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
      }


      /* List Headers & Rows - Responsive */
      /* Hide header on mobile */
      .list-header {
        display: none;
      }

      /* Show header on sm+ */
      @media (min-width: 640px) {
        .list-header {
          display: grid;
          grid-template-columns: 3rem 48px 1fr 4rem 3rem 3.5rem;
          /* Desktop columns */
          gap: 0.75rem;
          padding: 0;
          /* Remove padding from header row */
          border-bottom: 2px solid #e5e7eb;
          font-size: 0.75rem;
          font-weight: 600;
          color: #6b7280;
          text-transform: uppercase;
          background-color: #f9fafb;
          position: sticky;
          top: 0;
          z-index: 5;
        }

        .list-header>div {
          text-align: center;
          padding: 0.5rem 1rem;
          /* Add padding to header cells */
        }

        .list-header>div:nth-child(3) {
          text-align: left;
          margin-left: 1rem;
        }
      }

      .chart-row {
        position: relative;
        /* Positioning context for the peak badge */
        display: grid;
        /* Mobile: Art, Rank/Change, Title/Artist/Stats */
        grid-template-columns: 40px 3rem 1fr;
        gap: 0.75rem;
        /* Gap between main columns */
        align-items: center;
        /* Align items vertically */
        padding: 0;
        /* Remove padding from row */
        border-bottom: 1px solid #f3f4f6;
        cursor: pointer;
        transition: background-color 0.2s ease;
        min-height: 60px;
      }

      /* Apply padding to cells within the row */
      .chart-row>div {
        padding: 0.75rem 0.5rem;
        /* Default mobile padding */
      }

      /* Desktop layout */
      @media (min-width: 640px) {
        .chart-row {
          /* sm: Rank, Art, Title, Peak, Change, Weeks */
          grid-template-columns: 3rem 48px 1fr 4rem 3rem 3.5rem;
          gap: 0.75rem;
        }

        .chart-row>div {
          padding: 0.75rem 1rem;
          /* Desktop padding */
        }
      }

      .chart-row:last-child {
        border-bottom: none;
      }

      .chart-row:hover {
        background-color: #f0f9ff;
      }

      /* Column 1: Image */
      .list-image-container {
        width: 40px;
        height: 40px;
        sm: width: 48px;
        sm: height: 48px;
        flex-shrink: 0;
        border-radius: 0.25rem;
        overflow: hidden;
        background-color: #e5e7eb;
        padding: 0 !important;
        /* Override cell padding */
      }

      .list-image-placeholder {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #9ca3af;
        font-size: 1.25rem;
        sm: font-size: 1.5rem;
        font-weight: bold;
      }

      .list-image-container img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      /* Column 2: Rank & Change (Mobile) / Rank (Desktop) */
      .list-rank-change-col {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .list-rank {
        font-size: 1.5rem;
        font-weight: 700;
        color: #374151;
        text-align: center;
        line-height: 1.1;
      }

      .list-change {
        font-size: 0.8rem;
        text-align: center;
      }

      /* Desktop specific Rank/Change positioning */
      @media (min-width: 640px) {
        .list-rank-change-col {
          display: block;
        }

        /* Revert flex */
        /* Desktop styles for individual rank/change cols */
        .chart-row>div:nth-child(1) {
          /* Rank */
          font-size: 1.5rem;
          font-weight: 700;
          color: #374151;
          text-align: center;
        }

        .chart-row>div:nth-child(5) {
          /* Change */
          text-align: center;
          font-size: 0.9rem;
          color: #4b5563;
        }
      }


      /* Column 3: Title/Artist/Stats */
      .list-details-stats-col {
        display: flex;
        flex-direction: column;
      }

      .list-details {
        margin-left: 0;
        /* Remove margin */
      }

      .list-name {
        font-weight: 600;
        color: #111827;
        display: block;
        margin-bottom: 0;
        line-height: 1.3;
        font-size: 0.95rem;
      }

      .list-artist {
        font-size: 0.85rem;
        color: #6b7280;
        display: block;
        margin-bottom: 0.2rem;
        line-height: 1.2;
      }

      .list-secondary-stats {
        display: flex;
        /* Use flex for mobile */
        justify-content: space-between;
        /* Distribute items */
        align-items: center;
        /* Vertically align items */
        font-size: 0.75rem;
        color: #6b7280;
        margin-top: 0.25rem;
      }

      .list-secondary-stats>span {
        margin-right: 0;
        /* Remove margin, rely on justify-content */
      }

      .list-secondary-stats .stat-label {
        font-size: 0.65rem;
        text-transform: uppercase;
        color: #9ca3af;
        margin-left: 0.15rem;
      }

      /* Hide plays on mobile */
      .list-plays {
        display: none;
      }

      /* Peak indicator specific styles */
      .peak-indicator {
        margin-left: 0.25rem;
        font-size: 0.7rem;
        font-weight: 700;
        color: #f59e0b;
        background-color: #fffbeb;
        padding: 0.1rem 0.3rem;
        border-radius: 0.25rem;
        display: inline-flex;
        align-items: center;
      }

      /* Mobile absolute positioning for the badge */
      .peak-indicator-mobile {
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        z-index: 1;
      }

      /* Desktop layout for Title/Artist/Stats */
      @media (min-width: 640px) {
        .list-details-stats-col {
          /* No special styling needed, handled by main grid */
        }

        .list-details {
          margin-left: 1rem;
        }

        .list-name {
          font-size: 0.9rem;
        }

        .list-artist {
          font-size: 0.85rem;
        }

        .list-secondary-stats {
          display: none;
        }

        /* Hide mobile stats block */
        .list-plays {
          display: inline;
          font-size: 0.8rem;
          color: #a1a1aa;
        }

        /* Show plays */
        /* Desktop specific cols */
        .list-peak-info {
          display: block;
          text-align: center;
          font-size: 0.9rem;
          color: #4b5563;
        }

        .list-peak-info span {
          display: block;
          font-size: 0.75rem;
          color: #9ca3af;
        }

        .list-weeks {
          display: block;
          text-align: center;
          font-size: 0.9rem;
          color: #4b5563;
        }

        /* Revert peak indicator positioning for desktop */
        .peak-indicator {
          position: static;
          margin-left: 0.5rem;
          font-size: 0.75rem;
        }

        .peak-indicator-mobile {
          display: none;
        }

        /* Hide mobile badge on desktop */
      }


      /* Change Indicator Styles */
      .list-change span {
        font-size: 1rem;
        display: inline-block;
        width: 1.2em;
      }

      .list-change-up {
        color: #10b981;
      }

      .list-change-down {
        color: #ef4444;
      }

      .list-change-same {
        color: #6b7280;
      }

      .list-change-new,
      .list-change-re {
        color: #a855f7;
        font-weight: bold;
        font-size: 0.8rem;
      }

      /* Smaller for star/RE */

      /* Details & Artist Card Container */
      #detailsDisplayArea {
        display: none;
        margin: 1rem auto 0 auto;
        max-width: 1000px;
        width: 90%;
      }

      #detailsInfoContainer {
        background-color: #eef2ff;
        border: 1px solid #c7d2fe;
        color: #4338ca;
        text-align: center;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem 1.5rem;
        padding: 0.75rem 1rem;
        margin-bottom: 0.5rem;
        border-radius: 0.5rem;
        font-size: 0.9rem;
      }

      #artistCardContainer {
        background-color: #f9fafb;
        border: 1px solid #e5e7eb;
        color: #374151;
        cursor: pointer;
        transition: background-color 0.2s ease, border-color 0.2s ease;
        text-align: center;
        padding: 0.75rem 1rem;
        margin-bottom: 0.5rem;
        border-radius: 0.5rem;
        font-size: 0.9rem;
      }

      #artistCardContainer:hover {
        background-color: #f3f4f6;
        border-color: #d1d5db;
      }

      #artistCardContainer strong {
        color: #1f2937;
      }

      #artistCardContainer span {
        margin: 0 0.75rem;
        display: block;
        sm: display: inline;
      }

      /* Stack on mobile */
      .clickable-week-date {
        cursor: pointer;
        text-decoration: underline;
        color: #4f46e5;
        font-weight: 600;
      }

      .clickable-week-date:hover {
        color: #4338ca;
      }

      #currentWeekDisplay .clickable-week-date {
        text-decoration: none;
        color: inherit;
        font-weight: normal;
      }

      #currentWeekDisplay .clickable-week-date:hover {
        text-decoration: underline;
        color: #4f46e5;
      }

      /* Artist Top Songs List */
      #artistTopSongsContainer {
        background-color: #f9fafb;
        border: 1px solid #e5e7eb;
        display: none;
        padding: 0.75rem 1rem;
        margin-bottom: 0.5rem;
        border-radius: 0.5rem;
        font-size: 0.9rem;
      }

      #artistTopSongsContainer h4 {
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: #1f2937;
        text-align: center;
      }

      .artist-song-item {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 0.5rem 1rem;
        padding: 0.5rem 0;
        border-bottom: 1px solid #f3f4f6;
        font-size: 0.85rem;
      }

      .artist-song-item:last-child {
        border-bottom: none;
      }

      .artist-song-rank {
        font-weight: 600;
        text-align: right;
        color: #4b5563;
      }

      .artist-song-name {
        font-weight: 500;
        color: #3b82f6;
        cursor: pointer;
        text-decoration: underline;
      }

      .artist-song-name:hover {
        color: #2563eb;
      }

      .artist-song-plays {
        color: #6b7280;
        grid-column: 2;
      }

      .artist-song-peak-info {
        text-align: right;
        color: #6b7280;
      }

      .artist-song-peak-info .clickable-week-date {
        font-weight: normal;
      }

      /* History View Controls */
      #historyViewControls {
        display: none;
        text-align: center;
        margin-bottom: 1rem;
      }

      /* Export & Preview Styles */
      #exportContainer {
        position: absolute;
        left: -9999px;
        top: auto;
        width: 800px;
        background: linear-gradient(to bottom, #e0f2fe, #bfdbfe);
        padding: 40px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        min-height: 600px;
        font-family: 'Inter', sans-serif;
        font-size: 14px;
      }

      #exportContainer h3,
      #previewHtmlContainer h3 {
        text-align: center;
        margin-bottom: 15px;
        font-size: 1.5rem;
        font-weight: bold;
        color: #1e3a8a;
      }

      .export-grid-header,
      .export-grid-row {
        display: grid;
        grid-template-columns: 35px 48px 40px 1fr 50px 50px 40px 40px;
        gap: 0.5rem;
        align-items: center;
        width: 100%;
        max-width: 720px;
        margin: 0 auto;
        padding: 0;
      }

      .export-grid-header {
        background-color: #f8f9fa;
        font-weight: 600;
        color: #6b7280;
        text-transform: uppercase;
        font-size: 0.7rem;
        border-bottom: 1px solid #ddd !important;
        border-radius: 8px 8px 0 0;
      }

      .export-grid-row {
        font-size: 0.75rem;
        border-bottom: 1px solid #eee;
        background-color: white;
      }

      .export-grid-header>div,
      .export-grid-row>div {
        text-align: center;
        padding: 6px 5px;
        vertical-align: middle;
      }

      /* Add padding to cells */
      #exportContainer .export-grid-row:last-child,
      #previewHtmlContainer .export-grid-row:last-child {
        border-bottom: none;
        border-radius: 0 0 8px 8px;
      }

      .export-grid-header>div:nth-child(4),
      .export-grid-row>div:nth-child(4) {
        text-align: left;
      }

      .export-grid-row .list-rank {
        font-weight: 700;
        font-size: 0.9rem;
      }

      .export-grid-row .list-name {
        font-weight: 600;
        color: #111827;
        display: block;
        margin-bottom: 0;
        line-height: 1.2;
        font-size: 0.8rem;
      }

      .export-grid-row .list-artist {
        font-size: 0.7rem;
        color: #6b7280;
        display: block;
        line-height: 1.1;
      }

      .export-grid-row .list-change span {
        font-size: 0.75rem;
      }

      .export-grid-row .list-image-container {
        width: 40px;
        height: 40px;
        margin: auto;
        border-radius: 2px;
        overflow: hidden;
        background-color: #e5e7eb;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 !important;
      }

      /* Override cell padding */
      .export-grid-row .list-image-placeholder {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #9ca3af;
        font-size: 1.2rem;
        font-weight: bold;
      }

      .export-grid-row .list-image-container img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      /* Export Preview Modal */
      #exportPreviewModal {
        display: none;
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .modal-content {
        background-color: #fefefe;
        margin: auto;
        padding: 20px;
        border: 1px solid #888;
        width: 90%;
        max-width: 850px;
        border-radius: 8px;
        text-align: center;
      }

      #previewHtmlContainer {
        max-height: 70vh;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 15px;
        margin-bottom: 15px;
        background-color: #fff;
      }

      #previewContentWrapper {
        width: 720px;
        margin: 0 auto;
      }

      @media (max-width: 767px) {
        #previewHtmlContainer {
          overflow-x: auto;
        }

        #previewContentWrapper {
          transform: scale(0.75);
          transform-origin: top left;
          width: calc(100% / 0.75);
          max-width: none;
        }
      }

      #previewHtmlContainer .export-grid-header,
      #previewHtmlContainer .export-grid-row {
        /* Styles inherited */
      }

      #previewHtmlContainer .export-grid-header>div,
      #previewHtmlContainer .export-grid-row>div {
        padding: 6px 5px;
      }

      /* Ensure padding in preview */
      #previewHtmlContainer .export-grid-row .list-image-container {
        padding: 0 !important;
      }

      /* Override cell padding */
      .modal-actions {
        margin-top: 15px;
        display: flex;
        justify-content: center;
        gap: 1rem;
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body class="p-2 sm:p-6 md:p-8">
    <header class="text-center mb-6 sm:mb-10">
      <h1 class="text-3xl sm:text-4xl font-bold text-gray-800">
        My Music Billboard
      </h1>
      <p class="text-gray-600 mt-1 text-sm sm:text-base">
        Visualize your listening history
      </p>
    </header>

    <main>
      <section id="settingsSection" class="content-wrapper">
        <h3>Settings</h3>
        <div class="setting-item">
          <label for="windowDurationInput">Ranking Window:</label>
          <div class="input-group">
            <input type="number" id="windowDurationInput" min="1" value="4" />
            <select id="windowUnitSelect">
              <option value="weeks" selected>Weeks</option>
              <option value="months">Months</option>
              <option value="years">Years</option>
              <option value="all-time">All-Time</option>
            </select>
          </div>
        </div>
        <div class="setting-item">
          <label for="exportCountInput">Export Image Count (1-100):</label>
          <input
            type="number"
            id="exportCountInput"
            min="1"
            max="100"
            value="15"
          />
        </div>
        <div class="settings-actions">
          <button id="applySettingsBtn" class="button">
            Apply & Re-process
          </button>
          <button id="closeSettingsBtn" class="button">Close</button>
        </div>
      </section>

      <section
        id="uploadSection"
        class="mb-6 sm:mb-10 max-w-xl content-wrapper"
      >
        <h2 class="text-xl font-semibold mb-5 text-gray-700">
          Upload your Listening History CSV
        </h2>
        <div id="dropZone">
          <p class="text-gray-500">
            Drag & drop your CSV file here, or click to select
          </p>
          <input type="file" id="csvFileInput" accept=".csv" class="hidden" />
        </div>
        <div class="text-center mt-5">
          <button id="uploadButton" class="button">Select CSV File</button>
        </div>
        <p id="status" class="text-center">No file selected.</p>
      </section>

      <section id="chartSection" class="hidden content-wrapper">
        <div id="searchContainer">
          <input
            type="text"
            id="searchInput"
            placeholder="Search Track or Artist History..."
          />
          <div id="suggestions" class="hidden"></div>
        </div>

        <div class="controls-area">
          <div class="w-full sm:w-auto">
            <label
              for="entityType"
              class="mr-1 text-sm font-medium text-gray-700"
              >Show List:</label
            >
            <select id="entityType">
              <option value="track" selected>Top Tracks</option>
              <option value="artist">Top Artists</option>
            </select>
          </div>
          <div
            id="weekNavContainer"
            class="w-full sm:w-auto flex items-center justify-center"
          >
            <button id="prevWeekBtn" class="button" disabled>&lt; Prev</button>
            <span
              id="currentWeekDisplay"
              class="mx-2 text-sm text-gray-700 whitespace-nowrap"
              >Week: -</span
            >
            <button id="nextWeekBtn" class="button" disabled>Next &gt;</button>
          </div>
          <div
            id="jumpToWeekContainer"
            class="w-full sm:w-auto flex items-center justify-center"
          >
            <label
              for="weekJumpInput"
              class="mr-1 text-sm font-medium text-gray-700"
              >Jump to:</label
            >
            <input type="date" id="weekJumpInput" />
            <button id="jumpToWeekBtn" class="button ml-1">Go</button>
          </div>
          <div class="w-full sm:w-auto flex items-center justify-center gap-2">
            <button id="exportImageBtn" class="button">Export Top N</button>
            <button id="settingsBtn" class="button">Settings</button>
          </div>
        </div>

        <div id="historyViewControls">
          <button id="backToListBtn" class="button">
            &larr; Back to Top List
          </button>
        </div>

        <div id="detailsDisplayArea">
          <div id="detailsInfoContainer"></div>
          <div id="artistCardContainer"></div>
          <div id="artistTopSongsContainer"></div>
        </div>

        <div class="list-container-wrapper">
          <div class="chart-container">
            <canvas id="billboardChart"></canvas>
          </div>
          <div id="listHeaderContainer" style="display: none"></div>
          <div id="top100ListContainer"></div>
        </div>
        <div id="chartInfo" class="text-center text-gray-600 mt-3"></div>
      </section>

      <div id="exportPreviewModal" style="display: none">
        <div class="modal-content">
          <h4>Export Preview</h4>
          <div id="previewHtmlContainer">
            <div id="previewContentWrapper"></div>
          </div>
          <div class="modal-actions">
            <button id="confirmExportBtn" class="button">
              Generate Image & Download
            </button>
            <button id="cancelExportBtn" class="button">Cancel</button>
          </div>
        </div>
      </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@4.1.0/cdn.min.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
      integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // --- CONSTANTS ---
        const CONSTANTS = {
          COMPOSITE_KEY_SEPARATOR: ' --- ',
          ALL_TIME_MODE_VALUE: 'all-time',
          MAX_LIST_ITEMS: 100,
          DEFAULT_PEAK_VALUE: 101, // Value indicating 'not ranked' or worse than max
          DEFAULT_EXPORT_COUNT: 15,
          MIN_EXPORT_COUNT: 1,
          MAX_EXPORT_COUNT: 100,
          DEFAULT_WINDOW_WEEKS: 4,
          MIN_WINDOW_DURATION: 1,
          SEARCH_DEBOUNCE_MS: 150, // Delay for hiding suggestions on blur
          EXPORT_CONTAINER_ID: 'exportContainer',
          EXPORT_IMAGE_WIDTH: 800, // Width of the off-screen container for export
          EXPORT_PRELOAD_TIMEOUT: 150, // Short delay before generating canvas
          CHART_POINT_RADIUS: 3,
          CHART_POINT_HOVER_RADIUS: 5,
          CHART_TENSION: 0.1,
          CHART_BORDER_COLOR: '#4f46e5',
          CHART_BACKGROUND_COLOR: '#c7d2fe',
          EXPORT_BG_GRADIENT: 'linear-gradient(to bottom, #e0f2fe, #bfdbfe)',
          EXPORT_ROW_BG_BASE: '#FFFFFF',
          EXPORT_ROW_BG_POSITIVE: '#6EE7B7', // Light green
          EXPORT_ROW_BG_NEGATIVE: '#FCA5A5', // Light red
          EXPORT_ROW_BG_NEW: '#FEF9C3', // Light yellow
          EXPORT_MAX_PLAY_CHANGE_FACTOR: 1.0, // Max intensity for play change color (100% change)
        };
        // --- DOM Elements ---
        // Grouped by functionality for clarity
        // Upload Section
        const csvFileInput = document.getElementById('csvFileInput');
        const uploadButton = document.getElementById('uploadButton');
        const dropZone = document.getElementById('dropZone');
        const statusDiv = document.getElementById('status');
        const uploadSection = document.getElementById('uploadSection');

        // Chart/List Section
        const chartSection = document.getElementById('chartSection');
        const chartCanvas = document.getElementById('billboardChart');
        const chartContainerDiv = chartCanvas.parentElement; // Assumes canvas is direct child
        const listContainer = document.getElementById('top100ListContainer');
        const listHeaderContainer = document.getElementById(
          'listHeaderContainer'
        );
        const chartInfo = document.getElementById('chartInfo');

        // Controls
        const entityTypeSelect = document.getElementById('entityType');
        const searchInput = document.getElementById('searchInput');
        const suggestionsDiv = document.getElementById('suggestions');
        const prevWeekBtn = document.getElementById('prevWeekBtn');
        const nextWeekBtn = document.getElementById('nextWeekBtn');
        const currentWeekDisplay =
          document.getElementById('currentWeekDisplay');
        const weekNavContainer = document.getElementById('weekNavContainer');
        const weekJumpInput = document.getElementById('weekJumpInput');
        const jumpToWeekBtn = document.getElementById('jumpToWeekBtn');
        const jumpToWeekContainer = document.getElementById(
          'jumpToWeekContainer'
        );
        const exportImageBtn = document.getElementById('exportImageBtn');
        const settingsBtn = document.getElementById('settingsBtn');

        // History/Details View
        const historyViewControls = document.getElementById(
          'historyViewControls'
        );
        const backToListBtn = document.getElementById('backToListBtn');
        const detailsDisplayArea =
          document.getElementById('detailsDisplayArea');
        const detailsInfoContainer = document.getElementById(
          'detailsInfoContainer'
        );
        const artistCardContainer = document.getElementById(
          'artistCardContainer'
        );
        const artistTopSongsContainer = document.getElementById(
          'artistTopSongsContainer'
        );

        // Settings Section
        const settingsSection = document.getElementById('settingsSection');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');
        const applySettingsBtn = document.getElementById('applySettingsBtn');
        const windowDurationInput = document.getElementById(
          'windowDurationInput'
        );
        const windowUnitSelect = document.getElementById('windowUnitSelect');
        const exportCountInput = document.getElementById('exportCountInput');

        // Export Modal
        const exportPreviewModal =
          document.getElementById('exportPreviewModal');
        const previewHtmlContainer = document.getElementById(
          'previewHtmlContainer'
        );
        const previewContentWrapper = document.getElementById(
          'previewContentWrapper'
        );
        const confirmExportBtn = document.getElementById('confirmExportBtn');
        const cancelExportBtn = document.getElementById('cancelExportBtn');

        // --- Global State ---
        let mainChartInstance = null;
        let processedData = createEmptyProcessedData();
        let selectedHistoryEntity = { key: null, type: null };
        let currentWeekIndex = -1; // -1 signifies the latest week
        let slidingWindowWeeks = CONSTANTS.DEFAULT_WINDOW_WEEKS;
        let exportCountN = CONSTANTS.DEFAULT_EXPORT_COUNT;
        let tempExportFilename = ''; // Stores filename between preview and download
        let isAllTimeMode = false; // Flag for All-Time mode

        // --- Initialization ---
        checkDependencies();
        setupEventListeners();
        updateSettingsUI(); // Set initial values based on defaults

        // --- Utility Functions ---

        /** Creates an empty structure for processed data */
        function createEmptyProcessedData() {
          return {
            tracks: new Map(),
            artists: new Map(),
            allWeeks: [], // Sorted array of week start Date objects
            rawData: [], // Store original parsed data for reprocessing
          };
        }

        /** Checks if required external libraries are loaded */
        function checkDependencies() {
          const libraries = { Papa, Chart, dateFns, html2canvas };
          for (const libName in libraries) {
            if (
              typeof libraries[libName] === 'undefined' ||
              !libraries[libName]
            ) {
              const errorMsg = `Error: Required library '${libName}' failed to load.`;
              console.error(errorMsg);
              updateStatus(errorMsg, true);
              // Optionally, disable UI elements that depend on the library
              throw new Error(errorMsg); // Stop execution if critical libs are missing
            }
          }
          // Specifically check date-fns functions needed
          if (
            typeof dateFns?.format !== 'function' ||
            typeof dateFns?.startOfWeek !== 'function'
          ) {
            const errorMsg = 'Error: Required date-fns functions not found.';
            console.error(errorMsg);
            updateStatus(errorMsg, true);
            throw new Error(errorMsg);
          }
        }

        // --- Date Helpers ---
        // (Using optional chaining ?. just in case dateFns fails loading gracefully)

        /** Gets the start of the week (Sunday) for a given Date object */
        function getWeekStartDate(date) {
          return dateFns?.startOfWeek(date, { weekStartsOn: 0 });
        }

        /** Formats a Date object into 'yyyy-MM-dd' string */
        function formatDateKey(date) {
          return date ? dateFns?.format(date, 'yyyy-MM-dd') : null;
        }

        /** Formats a Date object for display, handling nulls */
        function formatDisplayDate(date) {
          return date ? dateFns?.format(date, 'yyyy-MM-dd') : 'N/A';
        }

        // --- Color Helpers ---
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
              }
            : null;
        }

        function rgbToHex(r, g, b) {
          return (
            '#' +
            ((1 << 24) + (r << 16) + (g << 8) + b)
              .toString(16)
              .slice(1)
              .toUpperCase()
          );
        }

        /** Interpolates between two hex colors based on a factor (0-1) */
        function interpolateColor(color1, color2, factor) {
          factor = Math.max(0, Math.min(1, factor));
          const rgb1 = hexToRgb(color1);
          const rgb2 = hexToRgb(color2);
          if (!rgb1 || !rgb2) return color1; // Fallback to color1 if parsing fails
          const r = Math.round(rgb1.r + factor * (rgb2.r - rgb1.r));
          const g = Math.round(rgb1.g + factor * (rgb2.g - rgb1.g));
          const b = Math.round(rgb1.b + factor * (rgb2.b - rgb1.b));
          return rgbToHex(r, g, b);
        }

        // --- Event Listener Setup ---
        function setupEventListeners() {
          // Upload
          uploadButton?.addEventListener('click', () => csvFileInput?.click());
          dropZone?.addEventListener('click', () => csvFileInput?.click());
          dropZone?.addEventListener('dragover', handleDragOver);
          dropZone?.addEventListener('dragleave', handleDragLeave);
          dropZone?.addEventListener('drop', handleDrop);
          csvFileInput?.addEventListener('change', handleFileSelect);

          // Controls
          entityTypeSelect?.addEventListener('change', handleEntityTypeChange);
          searchInput?.addEventListener('input', handleSearchInput);
          searchInput?.addEventListener('blur', () =>
            setTimeout(
              () => suggestionsDiv?.classList.add('hidden'),
              CONSTANTS.SEARCH_DEBOUNCE_MS
            )
          );
          suggestionsDiv?.addEventListener('mousedown', handleSuggestionClick); // mousedown fires before blur
          prevWeekBtn?.addEventListener('click', () => navigateWeek(-1));
          nextWeekBtn?.addEventListener('click', () => navigateWeek(1));
          jumpToWeekBtn?.addEventListener('click', handleJumpToWeek);
          exportImageBtn?.addEventListener('click', handleExportImageClick);
          settingsBtn?.addEventListener('click', openSettings);

          // List/History Interaction
          listContainer?.addEventListener('click', handleListItemClick);
          backToListBtn?.addEventListener('click', handleBackButtonClick);
          artistCardContainer?.addEventListener('click', handleArtistCardClick);
          artistTopSongsContainer?.addEventListener(
            'click',
            handleArtistTopSongClick
          );

          // Clickable Dates (delegated)
          detailsInfoContainer?.addEventListener('click', handleWeekDateClick);
          artistTopSongsContainer?.addEventListener(
            'click',
            handleWeekDateClick
          ); // Also handles clicks in top songs list
          weekNavContainer?.addEventListener('click', handleWeekDateClick); // For current week display

          // Settings Modal
          closeSettingsBtn?.addEventListener('click', closeSettings);
          applySettingsBtn?.addEventListener('click', handleApplySettings);

          // Export Modal
          cancelExportBtn?.addEventListener('click', closeExportModal);
          confirmExportBtn?.addEventListener('click', confirmAndDownloadExport);
        }

        // --- Event Handlers ---

        // File Upload Handlers
        function handleDragOver(event) {
          event.preventDefault();
          dropZone?.classList.add('dragover');
        }

        function handleDragLeave() {
          dropZone?.classList.remove('dragover');
        }

        function handleDrop(event) {
          event.preventDefault();
          dropZone?.classList.remove('dragover');
          const file = event.dataTransfer?.files[0];
          if (file && file.type === 'text/csv') {
            handleFile(file);
          } else {
            updateStatus('Please drop a CSV file.', true);
          }
        }

        function handleFileSelect(event) {
          const file = event.target?.files[0];
          if (file) {
            handleFile(file);
          }
        }

        // Control Handlers
        function handleEntityTypeChange() {
          // If not viewing specific history, update the list based on selection
          if (!selectedHistoryEntity.key) {
            updateChartOrList();
          }
        }

        /** Handles search input, filters tracks and artists, sorts, displays suggestions */
        function handleSearchInput(event) {
          const query = event.target.value.toLowerCase().trim();
          suggestionsDiv.innerHTML = '';
          if (query.length < 1) {
            suggestionsDiv.classList.add('hidden');
            return;
          }

          const trackMatches = [];
          processedData.tracks.forEach((data, key) => {
            const displayName = data.trackName || key;
            const artistName = data.artistName || 'Unknown Artist';
            if (
              displayName.toLowerCase().includes(query) ||
              artistName.toLowerCase().includes(query)
            ) {
              trackMatches.push({
                key: key,
                type: 'track',
                display: displayName,
                artist: artistName,
              });
            }
          });

          const artistMatches = [];
          processedData.artists.forEach((data, key) => {
            const displayName = data.artistName || key;
            if (displayName.toLowerCase().includes(query)) {
              artistMatches.push({
                key: key,
                type: 'artist',
                display: displayName,
              });
            }
          });

          let allMatches = [...trackMatches, ...artistMatches];

          // Sort results: Exact Match > Starts With > Artist Priority > Alphabetical
          allMatches.sort((a, b) => {
            const aLower = a.display.toLowerCase();
            const bLower = b.display.toLowerCase();
            const queryLower = query;

            // Priority checks
            const aIsExact = aLower === queryLower;
            const bIsExact = bLower === queryLower;
            const aStartsWith = aLower.startsWith(queryLower);
            const bStartsWith = bLower.startsWith(queryLower);

            if (aIsExact !== bIsExact) return aIsExact ? -1 : 1; // Exact matches first
            if (aStartsWith !== bStartsWith) return aStartsWith ? -1 : 1; // StartsWith matches second

            // Slight bias for artist if neither starts with query
            if (!aStartsWith && !bStartsWith) {
              if (a.type === 'artist' && b.type === 'track') return -1;
              if (b.type === 'artist' && a.type === 'track') return 1;
            }

            return a.display.localeCompare(b.display); // Alphabetical fallback
          });

          if (allMatches.length > 0) {
            allMatches.forEach((match) => {
              const div = document.createElement('div');
              div.dataset.key = match.key;
              div.dataset.type = match.type;
              let textHTML = `<span class="suggestion-type">[${
                match.type.charAt(0).toUpperCase() + match.type.slice(1)
              }]</span> ${match.display}`;
              if (match.type === 'track' && match.artist) {
                textHTML += ` <span class="suggestion-artist">- ${match.artist}</span>`;
              }
              div.innerHTML = textHTML;
              suggestionsDiv.appendChild(div);
            });
            suggestionsDiv.classList.remove('hidden');
          } else {
            suggestionsDiv.classList.add('hidden');
          }
        }

        /** Handles clicking a suggestion from the search dropdown */
        function handleSuggestionClick(event) {
          const targetDiv = event.target.closest('div[data-key][data-type]');
          if (targetDiv) {
            const key = targetDiv.dataset.key;
            const type = targetDiv.dataset.type;

            if (key && type) {
              selectedHistoryEntity = { key: key, type: type };
              entityTypeSelect.value = type; // Sync dropdown
              searchInput.value = ''; // Clear search
              suggestionsDiv.classList.add('hidden');
              updateChartOrList(); // Show history view
            }
          }
        }

        /** Handles clicking an item in the main Top 100 list */
        function handleListItemClick(event) {
          // Find the closest ancestor which is a chart row and has a data-key
          const chartRowElement = event.target.closest('.chart-row[data-key]');
          if (chartRowElement) {
            const key = chartRowElement.dataset.key;
            const type = entityTypeSelect.value; // Type is determined by the current list view
            // Ensure key is valid (not the placeholder '-')
            if (key && type && key !== '-') {
              selectedHistoryEntity = { key: key, type: type };
              searchInput.value = ''; // Clear search
              updateChartOrList(); // Switch to history view
            }
          }
        }

        /** Handles clicking the 'Back to Top List' button */
        function handleBackButtonClick() {
          selectedHistoryEntity = { key: null, type: null }; // Clear history selection
          searchInput.value = '';
          updateChartOrList(); // Renders list based on entityTypeSelect
        }

        /** Handles clicking the artist card shown in track history view */
        function handleArtistCardClick(event) {
          // Get the artist key stored on the card element
          const artistKey = event.currentTarget.dataset.artistKey;
          if (artistKey && processedData.artists.has(artistKey)) {
            selectedHistoryEntity = { key: artistKey, type: 'artist' };
            entityTypeSelect.value = 'artist'; // Update dropdown to 'artist'
            searchInput.value = '';
            updateChartOrList(); // Show artist history
          } else {
            console.warn('Could not find artist data for key:', artistKey);
            updateStatus('Could not load artist history.', true);
          }
        }

        /** Handles clicking a track name within the Artist's Top Songs list */
        function handleArtistTopSongClick(event) {
          // Target the specific clickable span with the track key
          const target = event.target.closest(
            '.artist-song-name[data-track-key]'
          );
          if (target) {
            event.stopPropagation(); // Prevent triggering other click listeners (like week date)
            const trackKey = target.dataset.trackKey;
            if (trackKey && processedData.tracks.has(trackKey)) {
              selectedHistoryEntity = { key: trackKey, type: 'track' };
              entityTypeSelect.value = 'track'; // Update dropdown to 'track'
              searchInput.value = '';
              updateChartOrList(); // Show track history
            }
          }
        }

        /** Handles clicking the 'Go' button for jumping to a specific week */
        function handleJumpToWeek() {
          const dateString = weekJumpInput.value;
          if (!dateString) {
            updateStatus('Please select a date to jump to.', true);
            return;
          }
          if (!processedData.allWeeks || processedData.allWeeks.length === 0) {
            updateStatus('No data loaded to jump within.', true);
            return;
          }
          try {
            const selectedDate = dateFns.parseISO(dateString + 'T00:00:00'); // Ensure parsing as local date start
            if (!dateFns.isValid(selectedDate)) {
              updateStatus('Invalid date selected.', true);
              return;
            }
            jumpToWeek(selectedDate);
          } catch (error) {
            console.error('Error parsing jump-to-week date:', error);
            updateStatus('Error processing selected date.', true);
          }
        }

        /** Handles clicks on elements with 'clickable-week-date' class and data-date attribute */
        function handleWeekDateClick(event) {
          const target = event.target.closest(
            '.clickable-week-date[data-date]'
          );
          if (target && target.dataset.date) {
            const dateString = target.dataset.date;
            if (!processedData.allWeeks || processedData.allWeeks.length === 0)
              return; // No data

            try {
              const selectedDate = dateFns.parseISO(dateString + 'T00:00:00');
              if (!dateFns.isValid(selectedDate)) return;
              jumpToWeek(selectedDate);
            } catch (error) {
              console.error('Error jumping to week from date click:', error);
              updateStatus('Error processing clicked date.', true);
            }
          }
        }

        /** Navigates weeks forward or backward in the list view */
        function navigateWeek(direction) {
          if (!processedData.allWeeks || processedData.allWeeks.length === 0)
            return;

          const maxIndex = processedData.allWeeks.length - 1;
          // If currentWeekIndex is -1 (latest), set it to maxIndex before navigating
          const currentIndex =
            currentWeekIndex === -1 ? maxIndex : currentWeekIndex;

          // Calculate new index, clamping between 0 and maxIndex
          const newIndex = Math.max(
            0,
            Math.min(maxIndex, currentIndex + direction)
          );

          if (newIndex !== currentWeekIndex) {
            currentWeekIndex = newIndex;
            selectedHistoryEntity = { key: null, type: null }; // Go back to list view
            searchInput.value = '';
            updateChartOrList();
          }
        }

        /** Jumps the list view to the week containing the selectedDate */
        function jumpToWeek(selectedDate) {
          const targetWeekStartDate = getWeekStartDate(selectedDate);
          // Find the index of this week start date in our sorted array
          const targetIndex = processedData.allWeeks.findIndex((week) =>
            dateFns.isSameDay(week, targetWeekStartDate)
          );

          if (targetIndex !== -1) {
            currentWeekIndex = targetIndex;
            selectedHistoryEntity = { key: null, type: null }; // Ensure list view
            searchInput.value = '';
            updateStatus(''); // Clear any previous error
            updateChartOrList();
          } else {
            // Date is outside the range of the data
            const firstWeek = processedData.allWeeks[0];
            const lastWeek =
              processedData.allWeeks[processedData.allWeeks.length - 1];
            updateStatus(
              `Selected date is outside the available data range (${formatDateKey(
                firstWeek
              )} to ${formatDateKey(lastWeek)}).`,
              true
            );
          }
        }

        // Settings Handlers
        function openSettings() {
          settingsSection.style.display = 'block';
          updateSettingsUI(); // Ensure UI reflects current settings
        }

        function closeSettings() {
          settingsSection.style.display = 'none';
        }

        /** Validates and applies settings, re-processing data if needed */
        function handleApplySettings() {
          const unit = windowUnitSelect.value;
          const newExportCount = parseInt(exportCountInput.value, 10);
          let newWindowWeeks = slidingWindowWeeks; // Keep current if All-Time
          let newIsAllTimeMode = false;

          // Validate Export Count
          if (
            isNaN(newExportCount) ||
            newExportCount < CONSTANTS.MIN_EXPORT_COUNT ||
            newExportCount > CONSTANTS.MAX_EXPORT_COUNT
          ) {
            updateStatus(
              `Export count must be between ${CONSTANTS.MIN_EXPORT_COUNT} and ${CONSTANTS.MAX_EXPORT_COUNT}.`,
              true
            );
            return;
          }

          if (unit === CONSTANTS.ALL_TIME_MODE_VALUE) {
            newIsAllTimeMode = true;
            // newWindowWeeks remains unchanged, it's not used in all-time mode calculation
          } else {
            const duration = parseInt(windowDurationInput.value, 10);
            if (isNaN(duration) || duration < CONSTANTS.MIN_WINDOW_DURATION) {
              updateStatus(
                `Window duration must be at least ${CONSTANTS.MIN_WINDOW_DURATION} ${unit}.`,
                true
              );
              return;
            }
            // Calculate new window duration in weeks
            switch (unit) {
              case 'months':
                newWindowWeeks = duration * 4;
                break;
              case 'years':
                newWindowWeeks = duration * 52;
                break;
              default:
                newWindowWeeks = duration; // Weeks
            }

            // Check against available data range if data is loaded
            if (
              processedData.allWeeks.length > 0 &&
              newWindowWeeks > processedData.allWeeks.length
            ) {
              updateStatus(
                `Window duration (${newWindowWeeks} weeks) cannot exceed available data range (${processedData.allWeeks.length} weeks).`,
                true
              );
              return;
            }
            if (newWindowWeeks < 1) {
              // Should be caught by MIN_WINDOW_DURATION check, but double-check
              updateStatus('Window duration must be at least 1 week.', true);
              return;
            }
          }

          const settingsChanged =
            newIsAllTimeMode !== isAllTimeMode ||
            newWindowWeeks !== slidingWindowWeeks ||
            newExportCount !== exportCountN;

          isAllTimeMode = newIsAllTimeMode;
          slidingWindowWeeks = newWindowWeeks; // Store even if all-time, for switching back
          exportCountN = newExportCount;
          exportImageBtn.textContent = `Export Top ${exportCountN}`;
          settingsSection.style.display = 'none';

          if (settingsChanged && processedData.rawData.length > 0) {
            // Re-process data only if settings actually changed and data exists
            updateStatus('Applying settings and re-processing data...');
            // Use setTimeout to allow UI update before potentially long processing
            setTimeout(() => {
              try {
                processListeningData(processedData.rawData); // Reprocess with new settings
                updateStatus(
                  'Settings applied and data re-processed successfully.'
                );
                // Reset view to the latest week's list
                currentWeekIndex = -1;
                selectedHistoryEntity = { key: null, type: null };
                updateChartOrList();
              } catch (error) {
                console.error(
                  'Error re-processing data after settings change:',
                  error
                );
                updateStatus(
                  `Error applying settings: ${
                    error.message || 'Unknown error'
                  }.`,
                  true
                );
              }
            }, 10); // Small delay
          } else if (!settingsChanged) {
            updateStatus('Settings unchanged.');
          } else {
            // Settings changed, but no data loaded yet
            updateStatus('Settings saved. Upload data to see changes.', false);
          }
        }

        // --- File Handling ---

        /** Parses the selected CSV file and initiates processing */
        function handleFile(file) {
          if (!file) return;
          updateStatus(`Processing ${file.name}...`);
          console.log('Starting file processing...');
          resetState(); // Reset application state before processing new file

          if (
            typeof Papa === 'undefined' ||
            !Papa ||
            typeof Papa.parse !== 'function'
          ) {
            updateStatus('Error: CSV parsing library failed.', true);
            resetState();
            return;
          }
          Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            dynamicTyping: { uts: true }, // Attempt to parse 'uts' as number
            complete: (results) => {
              console.log('CSV Parsing complete. Rows:', results.data?.length);

              if (results.errors.length > 0) {
                console.error('CSV Parsing Errors:', results.errors);
                updateStatus(
                  `Error parsing CSV: ${results.errors[0].message}. Check console.`,
                  true
                );
                resetState(); // Reset on critical parse error
                return;
              }
              if (!results.data || results.data.length === 0) {
                updateStatus(
                  'CSV file is empty or could not be parsed correctly.',
                  true
                );
                resetState();
                return;
              }

              // Validate required columns (optional, provide warning)
              validateCsvColumns(results.data[0]);

              processedData.rawData = results.data; // Store raw data for re-processing
              updateStatus('Parsing complete. Processing data...');

              // Use setTimeout to allow UI update before potentially long processing
              setTimeout(() => {
                try {
                  console.log('Calling processListeningData...');
                  processListeningData(processedData.rawData); // Initial processing
                  console.log('processListeningData finished.');

                  updateStatus(`Processed ${file.name}. Chart ready.`);
                  uploadSection?.classList.add('hidden');
                  chartSection?.classList.remove('hidden');
                  currentWeekIndex = -1; // Start at latest week
                  selectedHistoryEntity = { key: null, type: null };
                  setDateInputRange(); // Set min/max for date picker
                  updateChartOrList(); // Initial render
                  updateSettingsUI(); // Ensure settings UI matches loaded state
                } catch (error) {
                  console.error('Error during post-parse processing:', error);
                  updateStatus(
                    `Error processing data: ${
                      error.message || 'Unknown error'
                    }. Check console.`,
                    true
                  );
                  resetState(); // Reset on processing error
                }
              }, 10); // Small delay
            },
            error: (error) => {
              console.error('PapaParse Error:', error);
              updateStatus(`Error parsing file: ${error.message}`, true);
              resetState();
            },
          });
        }

        /** Checks for essential columns and warns if missing */
        function validateCsvColumns(firstRow) {
          const requiredColumns = ['uts', 'artist', 'track']; // Absolute minimum
          const recommendedColumns = [
            'artist_mbid',
            'track_mbid',
            'album_mbid',
          ]; // For better accuracy/art
          const actualColumns = Object.keys(firstRow || {});

          const missingRequired = requiredColumns.filter(
            (col) => !actualColumns.includes(col)
          );
          if (missingRequired.length > 0) {
            // This might be a fatal error depending on your logic, adjust severity
            updateStatus(
              `Error: Input CSV is missing required columns: ${missingRequired.join(
                ', '
              )}. Processing cannot continue.`,
              true
            );
            throw new Error(
              `Missing required CSV columns: ${missingRequired.join(', ')}`
            ); // Stop processing
          }

          const missingRecommended = recommendedColumns.filter(
            (col) => !actualColumns.includes(col)
          );
          if (missingRecommended.length > 0) {
            updateStatus(
              `Warning: Input CSV is missing recommended columns (${missingRecommended.join(
                ', '
              )}). Grouping/Art accuracy may be reduced.`,
              false
            );
          }
        }

        // --- State Management ---

        /** Resets the application to its initial state */
        function resetState() {
          processedData = createEmptyProcessedData();

          if (mainChartInstance) {
            mainChartInstance.destroy();
            mainChartInstance = null;
          }

          // Reset UI Elements
          chartSection?.classList.add('hidden');
          uploadSection?.classList.remove('hidden');
          settingsSection.style.display = 'none';
          detailsDisplayArea.style.display = 'none';
          historyViewControls.style.display = 'none';
          artistTopSongsContainer.style.display = 'none';
          listContainer.innerHTML = '';
          listHeaderContainer.style.display = 'none';
          chartContainerDiv.style.display = 'none';
          chartInfo.textContent = '';
          updateStatus('No file selected.');
          searchInput.value = '';
          suggestionsDiv.innerHTML = '';
          suggestionsDiv.classList.add('hidden');
          weekJumpInput.min = '';
          weekJumpInput.max = '';
          weekJumpInput.value = '';
          currentWeekDisplay.innerHTML = 'Week: -';

          // Reset variables
          selectedHistoryEntity = { key: null, type: null };
          currentWeekIndex = -1;
          slidingWindowWeeks = CONSTANTS.DEFAULT_WINDOW_WEEKS;
          exportCountN = CONSTANTS.DEFAULT_EXPORT_COUNT;
          isAllTimeMode = false;
          tempExportFilename = '';

          // Reset button states
          updateWeekNavControls(); // Disables buttons if no data
          exportImageBtn.textContent = `Export Top ${exportCountN}`;
          exportImageBtn.disabled = true; // Disable until data is loaded

          // Update settings UI to reflect defaults
          updateSettingsUI();
        }

        // --- Settings Functions ---
        function updateSettingsUI() {
          exportCountInput.value = exportCountN;
          if (isAllTimeMode) {
            windowUnitSelect.value = CONSTANTS.ALL_TIME_MODE_VALUE;
            windowDurationInput.value = '';
            windowDurationInput.disabled = true;
          } else {
            if (slidingWindowWeeks % 52 === 0 && slidingWindowWeeks >= 52) {
              windowDurationInput.value = slidingWindowWeeks / 52;
              windowUnitSelect.value = 'years';
            } else if (
              slidingWindowWeeks % 4 === 0 &&
              slidingWindowWeeks >= 4
            ) {
              windowDurationInput.value = slidingWindowWeeks / 4;
              windowUnitSelect.value = 'months';
            } else {
              // Default to weeks
              windowDurationInput.value = slidingWindowWeeks;
              windowUnitSelect.value = 'weeks';
            }
            windowDurationInput.disabled = false;
          }
        }

        /** Sets the min and max attributes for the week jump date input */
        function setDateInputRange() {
          if (
            !weekJumpInput ||
            !processedData.allWeeks ||
            processedData.allWeeks.length === 0
          )
            return;
          try {
            weekJumpInput.min = formatDateKey(processedData.allWeeks[0]);
            weekJumpInput.max = formatDateKey(
              processedData.allWeeks[processedData.allWeeks.length - 1]
            );
          } catch (e) {
            console.error('Error setting date input range:', e);
          }
        }

        /** Updates the status message display */
        function updateStatus(message, isError = false) {
          if (!statusDiv) return;
          statusDiv.textContent = message;
          statusDiv.classList.toggle('text-red-500', isError); // More concise toggle
          statusDiv.classList.toggle('text-gray-600', !isError); // Ensure default color is set
        }

        /** Updates the enabled/disabled state of week navigation buttons */
        function updateWeekNavControls() {
          if (!prevWeekBtn || !nextWeekBtn) return;
          const dataAvailable = processedData.allWeeks.length > 0;
          const maxIndex = dataAvailable
            ? processedData.allWeeks.length - 1
            : 0;
          const displayWeekIndex =
            currentWeekIndex === -1 ? maxIndex : currentWeekIndex;

          prevWeekBtn.disabled = !dataAvailable || displayWeekIndex <= 0;
          nextWeekBtn.disabled = !dataAvailable || displayWeekIndex >= maxIndex;
          // Also disable jump/export/settings if no data
          jumpToWeekBtn.disabled = !dataAvailable;
          weekJumpInput.disabled = !dataAvailable;
          exportImageBtn.disabled = !dataAvailable || selectedHistoryEntity.key; // Disable in history view too
          settingsBtn.disabled = !dataAvailable;
        }

        // --- Data Processing Logic ---

        /** Processes the raw listening data into structured format with history */
        function processListeningData(rawData) {
          console.log(
            `Processing listening data (Window: ${
              isAllTimeMode ? 'All-Time' : slidingWindowWeeks + ' weeks'
            })...`
          );
          const startTime = performance.now();

          // 1. Aggregate weekly counts and basic entity details
          const { weeklyCounts, entityDetails } =
            aggregateWeeklyCounts(rawData);
          const step1Time = performance.now();
          console.log(`Step 1 (Aggregation) took: ${step1Time - startTime} ms`);

          // 2. Get sorted list of all unique week start dates
          const allWeeks = Array.from(weeklyCounts.keys())
            .map(dateFns.parseISO)
            .sort(dateFns.compareAsc);
          if (allWeeks.length === 0)
            throw new Error('No valid listening data found after aggregation.');
          processedData.allWeeks = allWeeks;

          // 3. Calculate ranks for each week (Sliding Window or All-Time)
          const { tempTrackHistory, tempArtistHistory } = calculateRanks(
            allWeeks,
            weeklyCounts,
            isAllTimeMode
          );
          const step2Time = performance.now();
          console.log(`Step 2 (Ranking) took: ${step2Time - step1Time} ms`);

          // 4. Calculate status, peak position, weeks on chart, etc. and finalize data structure
          const finalTracks = calculateHistoryStats(
            tempTrackHistory,
            entityDetails.tracks
          );
          const finalArtists = calculateHistoryStats(
            tempArtistHistory,
            entityDetails.artists
          );
          const step3Time = performance.now();
          console.log(
            `Step 3 (History Stats) took: ${step3Time - step2Time} ms`
          );

          // Update global state
          processedData.tracks = finalTracks;
          processedData.artists = finalArtists;

          const endTime = performance.now();
          console.log(
            `Total data processing finished in ${endTime - startTime} ms.`
          );
        }

        /** Step 1: Aggregates listens per week for tracks and artists */
        function aggregateWeeklyCounts(rawData) {
          const weeklyCounts = new Map(); // weekKey -> { trackCounts: Map, artistCounts: Map }
          const entityDetails = { tracks: new Map(), artists: new Map() }; // key -> { details... }

          rawData.forEach((listen) => {
            // Basic validation
            if (typeof listen.uts !== 'number' || isNaN(listen.uts)) return;
            const trackName = (listen.track || '').trim();
            const artistName = (listen.artist || '').trim();
            if (!trackName || !artistName) return; // Skip entries without track or artist

            const listenDate = dateFns.fromUnixTime(listen.uts);
            const weekStartDate = getWeekStartDate(listenDate);
            const weekKey = formatDateKey(weekStartDate);

            const trackMbid = (listen.track_mbid || '').trim();
            const artistMbid = (listen.artist_mbid || '').trim();
            const albumMbid = (listen.album_mbid || '').trim();

            // Determine unique keys (prefer MBID, fallback to name/composite)
            const artistKey = artistMbid || artistName;
            const trackKey =
              trackMbid ||
              `${artistKey}${CONSTANTS.COMPOSITE_KEY_SEPARATOR}${trackName}`;

            // Initialize week if new
            if (!weeklyCounts.has(weekKey)) {
              weeklyCounts.set(weekKey, {
                trackCounts: new Map(),
                artistCounts: new Map(),
              });
            }
            const weekData = weeklyCounts.get(weekKey);

            // Increment counts
            weekData.trackCounts.set(
              trackKey,
              (weekData.trackCounts.get(trackKey) || 0) + 1
            );
            weekData.artistCounts.set(
              artistKey,
              (weekData.artistCounts.get(artistKey) || 0) + 1
            );

            // Update entity details (only store necessary info once)
            updateEntityDetail(
              entityDetails.tracks,
              trackKey,
              trackName,
              artistName,
              albumMbid,
              artistKey,
              listenDate
            );
            updateEntityDetail(
              entityDetails.artists,
              artistKey,
              null,
              artistName,
              null,
              null,
              listenDate
            );
          });

          return { weeklyCounts, entityDetails };
        }

        /** Helper for aggregateWeeklyCounts - Updates details for a track or artist */
        function updateEntityDetail(
          detailMap,
          key,
          trackName,
          artistName,
          albumMbid,
          artistKey,
          listenDate
        ) {
          let detail = detailMap.get(key);
          if (!detail) {
            // Initialize detail object only if it doesn't exist
            detail = {
              trackName: trackName, // Null for artists
              artistName: artistName,
              albumMbid: albumMbid, // Null for artists
              artistKey: artistKey, // Store artist's key on track detail for linking
              totalPlays: 0,
              firstPlayDate: listenDate,
              lastPlayDate: listenDate,
              // History will be added later
            };
            detailMap.set(key, detail);
          }

          // Update stats regardless of whether it was just created or existed
          detail.totalPlays += 1;
          if (dateFns.compareAsc(listenDate, detail.firstPlayDate) < 0) {
            detail.firstPlayDate = listenDate;
          }
          if (dateFns.compareAsc(listenDate, detail.lastPlayDate) > 0) {
            detail.lastPlayDate = listenDate;
          }

          // Fill in potentially missing info if found later (e.g., MBID found after name-based entry)
          // Note: This assumes MBID-based keys are preferred if available
          if (!detail.trackName && trackName) detail.trackName = trackName;
          if (!detail.artistName && artistName) detail.artistName = artistName;
          if (!detail.albumMbid && albumMbid) detail.albumMbid = albumMbid;
          if (!detail.artistKey && artistKey) detail.artistKey = artistKey;
        }

        /** Step 2: Calculates ranks based on mode (Sliding or All-Time) */
        function calculateRanks(allWeeks, weeklyCounts, isAllTime) {
          const tempTrackHistory = new Map();
          const tempArtistHistory = new Map();
          const cumulativeTrackPlays = new Map(); // Used only in all-time mode
          const cumulativeArtistPlays = new Map(); // Used only in all-time mode

          allWeeks.forEach((currentWeekDate, weekIndex) => {
            const currentWeekKey = formatDateKey(currentWeekDate);
            let windowTrackPlays = new Map();
            let windowArtistPlays = new Map();

            if (isAllTime) {
              // --- All-Time Calculation ---
              // Add current week's plays to cumulative totals
              const currentWeekData = weeklyCounts.get(currentWeekKey);
              if (currentWeekData) {
                currentWeekData.trackCounts.forEach((count, key) => {
                  cumulativeTrackPlays.set(
                    key,
                    (cumulativeTrackPlays.get(key) || 0) + count
                  );
                });
                currentWeekData.artistCounts.forEach((count, key) => {
                  cumulativeArtistPlays.set(
                    key,
                    (cumulativeArtistPlays.get(key) || 0) + count
                  );
                });
              }
              // Rank based on cumulative totals *up to this week*
              windowTrackPlays = new Map(cumulativeTrackPlays); // Copy map for ranking
              windowArtistPlays = new Map(cumulativeArtistPlays); // Copy map
            } else {
              // --- Sliding Window Calculation ---
              for (let i = 0; i < slidingWindowWeeks; i++) {
                const weekInWindowDate = dateFns.subWeeks(currentWeekDate, i);
                const weekInWindowKey = formatDateKey(weekInWindowDate);

                if (weeklyCounts.has(weekInWindowKey)) {
                  const weekData = weeklyCounts.get(weekInWindowKey);
                  weekData.trackCounts.forEach((count, key) =>
                    windowTrackPlays.set(
                      key,
                      (windowTrackPlays.get(key) || 0) + count
                    )
                  );
                  weekData.artistCounts.forEach((count, key) =>
                    windowArtistPlays.set(
                      key,
                      (windowArtistPlays.get(key) || 0) + count
                    )
                  );
                }
              }
            }

            // Rank and store history entry for the current week
            const rankedTracks = Array.from(windowTrackPlays.entries())
              .sort(([, playsA], [, playsB]) => playsB - playsA)
              .slice(0, CONSTANTS.MAX_LIST_ITEMS);

            rankedTracks.forEach(([key, plays], index) => {
              if (!tempTrackHistory.has(key)) tempTrackHistory.set(key, []);
              tempTrackHistory.get(key).push({
                week: currentWeekDate,
                rank: index + 1,
                playsInWindow: plays,
              });
            });

            const rankedArtists = Array.from(windowArtistPlays.entries())
              .sort(([, playsA], [, playsB]) => playsB - playsA)
              .slice(0, CONSTANTS.MAX_LIST_ITEMS);
            rankedArtists.forEach(([key, plays], index) => {
              if (!tempArtistHistory.has(key)) tempArtistHistory.set(key, []);
              tempArtistHistory.get(key).push({
                week: currentWeekDate,
                rank: index + 1,
                playsInWindow: plays,
              });
            });
          });

          return { tempTrackHistory, tempArtistHistory };
        }

        /** Step 3: Calculates peak, status, weeks on chart etc. for each entity's history */
        function calculateHistoryStats(tempHistoryMap, detailsMap) {
          const finalDataMap = new Map(); // key -> { ...details, history: [enriched history entries] }

          tempHistoryMap.forEach((history, key) => {
            // Ensure history is sorted chronologically
            history.sort((a, b) => dateFns.compareAsc(a.week, b.week));

            const enrichedHistory = [];
            let overallPeakPosition = CONSTANTS.DEFAULT_PEAK_VALUE; // Start with a value indicating "not peaked yet"

            for (let i = 0; i < history.length; i++) {
              const currentEntry = history[i];
              const prevWeekDate = dateFns.subWeeks(currentEntry.week, 1);

              // Find the original history entry for the *exact* previous week, if it exists
              const prevHistoryEntryOriginal = history.find(
                (h) => i > 0 && dateFns.isSameDay(h.week, prevWeekDate)
              );

              const currentRank = currentEntry.rank;
              const lastWeekRank = prevHistoryEntryOriginal
                ? prevHistoryEntryOriginal.rank
                : null;
              const lastWeekPlays = prevHistoryEntryOriginal
                ? prevHistoryEntryOriginal.playsInWindow
                : null;

              // Calculate current overall peak up to this point
              // Note: This recalculates peak for every week, could optimize if needed
              const currentOverallPeak = history
                .slice(0, i + 1) // Include current entry
                .reduce(
                  (minPeak, entry) => Math.min(minPeak, entry.rank),
                  CONSTANTS.DEFAULT_PEAK_VALUE
                );

              // Determine Peak Status
              let peakStatus = null;
              if (currentRank === currentOverallPeak) {
                // Check if this week *set* a new overall peak compared to the peak *before* this week
                const peakBeforeThisWeek =
                  i > 0
                    ? enrichedHistory[i - 1].peakPosition
                    : CONSTANTS.DEFAULT_PEAK_VALUE;
                if (currentOverallPeak < peakBeforeThisWeek) {
                  peakStatus = 'PEAK'; // New absolute peak achieved this week
                } else if (
                  lastWeekRank !== null &&
                  lastWeekRank > currentRank
                ) {
                  // If rank improved and matched the existing peak, it's a re-peak
                  peakStatus = 'RE-PEAK';
                }
                // If it matched the peak but didn't improve from last week, no status change
              }

              // Determine Rank Status (Change from last week)
              let status = null;
              if (lastWeekRank !== null) {
                status = lastWeekRank - currentRank; // Positive = Up, Negative = Down, 0 = Same
              } else {
                // Check if there's any history *before* the theoretical previous week
                const hasHistoryBeforePrevWeek = history.some(
                  (h) => i > 0 && dateFns.compareAsc(h.week, prevWeekDate) < 0
                );
                status = hasHistoryBeforePrevWeek ? 'RE-ENTRY' : 'NEW';
              }

              // Calculate Play Percentage Change
              let playPercentChange = null;
              if (
                lastWeekPlays !== null &&
                typeof currentEntry.playsInWindow === 'number'
              ) {
                if (lastWeekPlays > 0) {
                  playPercentChange =
                    ((currentEntry.playsInWindow - lastWeekPlays) /
                      lastWeekPlays) *
                    100;
                } else if (currentEntry.playsInWindow > 0) {
                  playPercentChange = Infinity; // Change from 0 to positive
                } else {
                  playPercentChange = 0; // 0 to 0
                }
              }

              enrichedHistory.push({
                ...currentEntry,
                status: status, // NEW, RE-ENTRY, or rank difference number
                peakPosition:
                  currentOverallPeak <= CONSTANTS.MAX_LIST_ITEMS
                    ? currentOverallPeak
                    : null, // Store the best rank achieved *up to this week*
                peakStatus: peakStatus, // PEAK, RE-PEAK, or null
                weeksOnChart: i + 1, // Simple count of weeks in the history array
                playPercentChange: playPercentChange,
                lastWeekRank: lastWeekRank, // Store for display convenience
              });
            }

            // Combine details with the enriched history
            const details = detailsMap.get(key) || {}; // Get existing details or empty object
            // Ensure basic info exists if somehow missed in aggregation
            if (!details.artistName)
              details.artistName = key.includes(
                CONSTANTS.COMPOSITE_KEY_SEPARATOR
              )
                ? key.split(CONSTANTS.COMPOSITE_KEY_SEPARATOR)[0]
                : finalDataMap === processedData.artists
                ? key
                : 'Unknown Artist';
            if (
              !details.trackName &&
              key.includes(CONSTANTS.COMPOSITE_KEY_SEPARATOR)
            )
              details.trackName = key.split(
                CONSTANTS.COMPOSITE_KEY_SEPARATOR
              )[1];

            finalDataMap.set(key, { ...details, history: enrichedHistory });
          });

          return finalDataMap;
        }

        // --- Rendering Functions ---

        /** Main function to update the display (list or history chart) */
        function updateChartOrList() {
          if (
            !chartCanvas ||
            !listContainer ||
            !detailsDisplayArea ||
            !historyViewControls ||
            !artistCardContainer ||
            !artistTopSongsContainer ||
            !chartContainerDiv ||
            !listHeaderContainer
          ) {
            console.error('Critical display containers not found in the DOM.');
            updateStatus('UI Error: Display elements missing.', true);
            return;
          }
          if (!processedData.allWeeks || processedData.allWeeks.length === 0) {
            if (chartInfo)
              chartInfo.textContent =
                'No chart data to display. Upload a CSV file.';
            if (mainChartInstance) {
              mainChartInstance.destroy();
              mainChartInstance = null;
            }
            listContainer.innerHTML = '';
            listHeaderContainer.style.display = 'none';
            chartContainerDiv.style.display = 'none';
            detailsDisplayArea.style.display = 'none';
            historyViewControls.style.display = 'none';
            updateWeekNavControls(); // Disable buttons
            exportImageBtn.style.display = 'flex'; // Keep export visible but disabled
            settingsBtn.style.display = 'flex'; // Keep settings visible but disabled
            return;
          }

          const isHistoryView = !!selectedHistoryEntity.key;
          const activeEntityType = isHistoryView
            ? selectedHistoryEntity.type
            : entityTypeSelect.value; // Determine type based on view
          const dataMap =
            activeEntityType === 'track'
              ? processedData.tracks
              : processedData.artists;

          // Destroy existing chart if switching views or entity types
          if (mainChartInstance) {
            mainChartInstance.destroy();
            mainChartInstance = null;
          }

          // Configure visibility based on view mode
          listContainer.style.display = isHistoryView ? 'none' : 'block';
          listHeaderContainer.style.display = isHistoryView ? 'none' : 'block'; // CSS handles mobile hiding
          chartContainerDiv.style.display = isHistoryView ? 'block' : 'none';
          historyViewControls.style.display = isHistoryView ? 'block' : 'none';
          detailsDisplayArea.style.display = isHistoryView ? 'block' : 'none';
          weekNavContainer.style.display = !isHistoryView ? 'flex' : 'none';
          jumpToWeekContainer.style.display = !isHistoryView ? 'flex' : 'none';
          exportImageBtn.style.display = !isHistoryView ? 'flex' : 'none'; // Only show export in list view

          // --- Render Content ---
          let viewTitle = '';
          if (isHistoryView) {
            const entityData = dataMap.get(selectedHistoryEntity.key);
            if (!entityData) {
              console.error(
                `Data not found for ${activeEntityType} key: ${selectedHistoryEntity.key}`
              );
              updateStatus(
                `Error: Could not load history for selected ${activeEntityType}.`,
                true
              );
              handleBackButtonClick(); // Go back to list if data is missing
              return;
            }

            const displayName =
              activeEntityType === 'track'
                ? entityData.trackName
                : entityData.artistName;
            viewTitle = `${
              activeEntityType === 'track' ? 'Track' : 'Artist'
            } History: ${displayName || selectedHistoryEntity.key}`;
            if (activeEntityType === 'track' && entityData.artistName) {
              viewTitle += ` by ${entityData.artistName}`;
            }

            renderDetailsPanel(entityData, activeEntityType);
            // Render chart *after* its container is visible
            setTimeout(
              () => renderHistoryChart(displayName, entityData.history),
              0
            );
          } else {
            // List View
            const displayWeekIndex =
              currentWeekIndex === -1
                ? processedData.allWeeks.length - 1
                : currentWeekIndex;
            // Basic bounds check
            if (
              displayWeekIndex < 0 ||
              displayWeekIndex >= processedData.allWeeks.length
            ) {
              console.error('Invalid week index:', displayWeekIndex);
              updateStatus('Error: Invalid week selected.', true);
              return; // Or reset index
            }

            const displayWeekDate = processedData.allWeeks[displayWeekIndex];
            const displayWeekKey = formatDateKey(displayWeekDate);

            viewTitle = `Top ${CONSTANTS.MAX_LIST_ITEMS} ${activeEntityType}s: Week of ${displayWeekKey}`;
            const listData = prepareTop100ListData(
              activeEntityType,
              dataMap,
              displayWeekKey
            );

            renderListHeader(); // Render header (CSS hides on mobile)
            renderTop100List(listData, listContainer); // Render the list content

            // Update the current week display span
            if (currentWeekDisplay) {
              currentWeekDisplay.innerHTML = `Week: <span class="clickable-week-date" data-date="${displayWeekKey}">${displayWeekKey}</span>`;
            }
          }

          if (chartInfo) chartInfo.textContent = viewTitle;
          updateWeekNavControls(); // Update button states based on current index/data
          console.log('Display updated.');
        }

        /** Renders the details panel in history view */
        function renderDetailsPanel(entityData, entityType) {
          const overallPeak =
            entityData.history?.reduce(
              (min, entry) =>
                Math.min(
                  min,
                  entry.peakPosition ?? CONSTANTS.DEFAULT_PEAK_VALUE
                ),
              CONSTANTS.DEFAULT_PEAK_VALUE
            ) ?? CONSTANTS.DEFAULT_PEAK_VALUE; // Overall best peak from enriched history

          const peakEntry = entityData.history?.find(
            (entry) => entry.rank === overallPeak
          );
          const peakWeekDate = peakEntry?.week;

          const peakDisplayValue =
            overallPeak <= CONSTANTS.MAX_LIST_ITEMS ? overallPeak : '-';
          const createClickableDateHTML = (date) =>
            date
              ? `<strong class="clickable-week-date" data-date="${formatDateKey(
                  date
                )}">${formatDisplayDate(date)}</strong>`
              : `<strong>N/A</strong>`;

          detailsInfoContainer.innerHTML = `
            <span>Total Plays: <strong>${
              entityData.totalPlays || 0
            }</strong></span>
            <span>First Play: ${createClickableDateHTML(
              entityData.firstPlayDate
            )}</span>
            <span>Last Play: ${createClickableDateHTML(
              entityData.lastPlayDate
            )}</span>
            <span>All-Time Peak: <strong>${peakDisplayValue}</strong></span>
            <span>Peak Week: ${createClickableDateHTML(peakWeekDate)}</span>
        `;

          // Artist Card / Top Songs Section
          artistCardContainer.style.display = 'none';
          artistTopSongsContainer.style.display = 'none';
          artistCardContainer.removeAttribute('data-artist-key'); // Clear previous key

          if (entityType === 'track' && entityData.artistKey) {
            // Show artist card for tracks
            const artistData = processedData.artists.get(entityData.artistKey);
            if (artistData) {
              artistCardContainer.innerHTML = `
                    Artist: <strong>${
                      artistData.artistName || entityData.artistKey
                    }</strong>
                    <span>First Play: ${createClickableDateHTML(
                      artistData.firstPlayDate
                    )}</span>
                    <span>Last Play: ${createClickableDateHTML(
                      artistData.lastPlayDate
                    )}</span>
                    <span class="text-xs text-blue-600 hover:underline">(View Artist History)</span>
                `;
              artistCardContainer.dataset.artistKey = entityData.artistKey; // Store key for click handler
              artistCardContainer.style.display = 'block';
            }
          } else if (entityType === 'artist') {
            // Show top songs list for artists
            displayArtistTopSongs(selectedHistoryEntity.key); // Pass the artist key
          }
        }

        /** Renders the history line chart */
        function renderHistoryChart(displayName, history) {
          if (!chartCanvas) return;
          // No need to destroy here, updateChartOrList handles it before calling render functions
          // if (mainChartInstance) mainChartInstance.destroy();

          const { labels, datasets } = prepareHistoryChartData(
            displayName,
            history
          );
          const config = {
            type: 'line',
            data: { labels, datasets },
            options: getLineChartOptions('Rank', 'Week Starting', true), // Enable clicks
          };

          try {
            mainChartInstance = new Chart(chartCanvas, config);
          } catch (e) {
            console.error('Error creating history chart:', e);
            updateStatus('Error displaying chart. Check console.', true);
          }
        }

        /** Prepares data specifically for the history line chart */
        function prepareHistoryChartData(entityName, historyArray) {
          // Use allWeeks as the definitive X-axis labels
          const labels = processedData.allWeeks.map(formatDateKey);
          // Create a map for quick lookup of rank by week key
          const historyRankMap = new Map(
            historyArray.map((h) => [formatDateKey(h.week), h.rank])
          );

          // Map labels to ranks, inserting null for weeks the entity wasn't charted
          const chartDataPoints = labels.map(
            (label) => historyRankMap.get(label) ?? null
          );

          const datasets = [
            {
              label: `${entityName} Rank`,
              data: chartDataPoints,
              borderColor: CONSTANTS.CHART_BORDER_COLOR,
              backgroundColor: CONSTANTS.CHART_BACKGROUND_COLOR,
              tension: CONSTANTS.CHART_TENSION,
              fill: false, // Don't fill area under line
              spanGaps: false, // Don't connect points with nulls between them
              pointRadius: CONSTANTS.CHART_POINT_RADIUS,
              pointHoverRadius: CONSTANTS.CHART_POINT_HOVER_RADIUS,
            },
          ];

          return { labels, datasets };
        }

        /** Prepares the data array for rendering the Top 100 list for a specific week */
        function prepareTop100ListData(entityType, dataMap, weekKey) {
          const listData = [];
          const weekDate = dateFns.parseISO(weekKey); // Date object for the target week

          dataMap.forEach((data, key) => {
            // Find the specific history entry for the target week
            const rankEntry = data.history?.find(
              (h) => formatDateKey(h.week) === weekKey
            );

            if (rankEntry) {
              // Get necessary details directly from the enriched rankEntry
              listData.push({
                key: key,
                name:
                  (entityType === 'track' ? data.trackName : data.artistName) ||
                  key,
                artistName: entityType === 'track' ? data.artistName : null,
                albumMbid: entityType === 'track' ? data.albumMbid : null,
                rank: rankEntry.rank,
                plays: rankEntry.playsInWindow,
                status: rankEntry.status, // NEW, RE-ENTRY, or rank diff number
                peak: rankEntry.peakPosition, // Peak achieved *up to* this week
                peakStatus: rankEntry.peakStatus, // PEAK, RE-PEAK, or null
                weeksOnChart: rankEntry.weeksOnChart,
                playPercentChange: rankEntry.playPercentChange,
                lastWeekRank: rankEntry.lastWeekRank, // Rank from the previous week
              });
            }
          });

          // Sort the collected data by rank for this week
          listData.sort((a, b) => a.rank - b.rank);
          return listData;
        }

        /** Renders the header row for the Top 100 list (desktop view) */
        function renderListHeader() {
          if (!listHeaderContainer) return;
          // This header is hidden on small screens by CSS rules
          listHeaderContainer.innerHTML = `
            <div class="list-header">
                <div>Rank</div>
                <div></div> <div>Title</div>
                <div>Peak</div>
                <div>Change</div>
                <div>Weeks</div>
            </div>
        `;
          listHeaderContainer.style.display = 'block'; // Ensure visible if data loaded
        }

        /** Renders the Top 100 list items into the specified container */
        function renderTop100List(listData, container) {
          if (!container) return;
          container.innerHTML = ''; // Clear previous list

          if (!listData || listData.length === 0) {
            container.innerHTML =
              '<p class="text-center text-gray-500 p-4">No ranking data available for this week.</p>';
            return;
          }

          listData.forEach((item) => {
            const rowElement = document.createElement('div');
            rowElement.className = 'chart-row'; // Base class for grid structure
            if (item.key && item.key !== '-') {
              rowElement.dataset.key = item.key; // Make row clickable if it has a valid key
              rowElement.style.cursor = 'pointer';
            } else {
              rowElement.style.cursor = 'default'; // Not clickable
            }

            const { statusIndicator, statusClass } = getStatusIndicatorHTML(
              item.status
            );
            const peakIndicatorHTML = getPeakIndicatorHTML(item.peakStatus); // Gets mobile and desktop versions
            const imageHTML = getImageHTML(item, entityTypeSelect.value); // Pass entity type

            const peakDisplay = item.peak ?? '-';
            const weeksDisplay = item.weeksOnChart ?? '-';
            const lastWeekDisplay = item.lastWeekRank ?? '-'; // Rank from previous week

            // Assemble row HTML using template literals and helper functions
            rowElement.innerHTML = `
            ${imageHTML}

            <div class="list-rank-change-col sm:hidden">
                <div class="list-rank">${item.rank}</div>
                <div class="list-change ${statusClass}">${statusIndicator}</div>
            </div>

            <div class="list-rank hidden sm:block">${item.rank}</div>

            <div class="list-details-stats-col">
                <div class="list-details">
                    <span class="list-name">${item.name}</span>
                    ${
                      item.artistName
                        ? `<span class="list-artist">${item.artistName}</span>`
                        : ''
                    }
                    <span class="list-plays hidden sm:inline">
                       Plays: ${item.plays} ${peakIndicatorHTML.desktop}
                    </span>
                </div>
                <div class="list-secondary-stats sm:hidden">
                    <span>${lastWeekDisplay}<span class="stat-label">LW</span></span>
                    <span>${peakDisplay}<span class="stat-label">PK</span></span>
                    <span>${weeksDisplay}<span class="stat-label">WOC</span></span>
                </div>
            </div>

            <div class="list-peak-info hidden sm:block">
                ${peakDisplay}
                <span>Peak</span>
            </div>

            <div class="list-change ${statusClass} hidden sm:block">
                ${statusIndicator}
            </div>

            <div class="list-weeks hidden sm:block">${weeksDisplay}</div>

            ${peakIndicatorHTML.mobile}
        `;
            container.appendChild(rowElement);
          });
        }

        // --- List Rendering Helpers ---

        /** Generates HTML for status indicator (NEW, RE, ▲, ▼, =) */
        function getStatusIndicatorHTML(statusValue) {
          let statusIndicator = '-';
          let statusClass = 'list-change-same';

          if (statusValue === 'NEW') {
            statusIndicator = '★'; // New Entry Star
            statusClass = 'list-change-new';
          } else if (statusValue === 'RE-ENTRY') {
            statusIndicator = 'RE'; // Re-Entry
            statusClass = 'list-change-re';
          } else if (typeof statusValue === 'number') {
            if (statusValue > 0) {
              statusIndicator = `<span>▲</span> ${statusValue}`; // Up
              statusClass = 'list-change-up';
            } else if (statusValue < 0) {
              statusIndicator = `<span>▼</span> ${Math.abs(statusValue)}`; // Down
              statusClass = 'list-change-down';
            } else {
              // statusValue === 0
              statusIndicator = '='; // Same
              statusClass = 'list-change-same';
            }
          }
          return { statusIndicator, statusClass };
        }

        /** Generates HTML for peak status indicators (mobile and desktop) */
        function getPeakIndicatorHTML(peakStatus) {
          let peakIndicatorText = '';
          if (peakStatus === 'PEAK') peakIndicatorText = '▲ Peak';
          else if (peakStatus === 'RE-PEAK') peakIndicatorText = '▲ Re-Peak';

          const desktopHTML = peakIndicatorText
            ? `<span class="peak-indicator hidden sm:inline-flex">${peakIndicatorText}</span>`
            : '';
          const mobileHTML = peakIndicatorText
            ? `<span class="peak-indicator peak-indicator-mobile sm:hidden">${peakIndicatorText}</span>`
            : '';

          return { desktop: desktopHTML, mobile: mobileHTML };
        }

        /** Generates image HTML (cover art or placeholder) */
        function getImageHTML(item, entityType) {
          let initials = '?';
          if (item.name && item.name !== '-') {
            initials = item.name.charAt(0).toUpperCase();
            if (entityType === 'track' && item.artistName) {
              initials += item.artistName.charAt(0).toUpperCase();
            } else if (entityType === 'artist' && item.name.length > 1) {
              initials = item.name.substring(0, 2).toUpperCase();
            }
          }
          // Sanitize initials for use in JS string literal within onerror
          const safeInitials = initials
            .replace(/['"\\]/g, '\\$&')
            .replace(/\n/g, '');

          // Define the onerror fallback logic compactly
          const onErrorLogic = `this.onerror=null;const p=this.parentElement;if(p&&p.classList.contains('list-image-container')){const ph=document.createElement('div');ph.className='list-image-placeholder';ph.textContent='${safeInitials}';p.innerHTML='';p.appendChild(ph)}else{this.remove()}`;

          // Attempt to use Cover Art Archive if it's a track with an album MBID
          if (entityType === 'track' && item.albumMbid) {
            return `
                <div class="list-image-container">
                    <img src="https://coverartarchive.org/release/${item.albumMbid}/front-250"
                         alt="Cover Art for ${item.name}"
                         loading="lazy"
                         onerror="${onErrorLogic}">
                </div>`;
          } else {
            // Fallback to placeholder
            return `
                <div class="list-image-container">
                    <div class="list-image-placeholder">${initials}</div>
                </div>`;
          }
        }

        /** Generates Chart.js options object */
        function getLineChartOptions(yLabel, xLabel, enableClicks = false) {
          const options = {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                reverse: true, // Rank 1 at the top
                title: { display: true, text: yLabel },
                min: 1,
                max: CONSTANTS.MAX_LIST_ITEMS, // Ensure scale goes up to 100
                ticks: { precision: 0 },
              },
              x: {
                title: { display: true, text: xLabel },
                ticks: {
                  autoSkip: true,
                  maxTicksLimit: 15, // Limit number of date labels shown
                  maxRotation: 70,
                  minRotation: 0,
                },
              },
            },
            plugins: {
              legend: { display: true },
              tooltip: {
                callbacks: {
                  // Show rank or "Not Ranked" in tooltip
                  label: (ctx) =>
                    ctx.parsed.y !== null
                      ? `Rank: ${ctx.parsed.y}`
                      : 'Not Ranked',
                },
              },
            },
            interaction: {
              mode: 'index', // Show tooltips for all datasets at that index
              intersect: false, // Tooltip triggers even if not exactly hovering point
            },
          };

          // Add onClick handler if enabled (for history chart -> list view)
          if (enableClicks) {
            options.onClick = (event, elements) => {
              if (elements.length > 0) {
                const clickedIndex = elements[0].index;
                if (
                  clickedIndex >= 0 &&
                  clickedIndex < processedData.allWeeks.length
                ) {
                  const clickedWeekDate = processedData.allWeeks[clickedIndex];
                  console.log(
                    'Chart week clicked:',
                    formatDateKey(clickedWeekDate)
                  );
                  jumpToWeek(clickedWeekDate); // Use jumpToWeek to handle navigation
                }
              }
            };
          }
          return options;
        }

        /** Displays top N songs for an artist in the history view */
        function displayArtistTopSongs(viewedArtistKey) {
          if (!artistTopSongsContainer) return;
          artistTopSongsContainer.innerHTML = ''; // Clear previous
          artistTopSongsContainer.style.display = 'none'; // Hide initially

          const viewedArtistData = processedData.artists.get(viewedArtistKey);
          const displayArtistName =
            viewedArtistData?.artistName || viewedArtistKey;

          const artistTracks = [];
          processedData.tracks.forEach((trackData, trackKey) => {
            // Match using the stored artistKey on the track data
            if (trackData.artistKey === viewedArtistKey) {
              const overallPeak =
                trackData.history?.reduce(
                  (min, entry) =>
                    Math.min(
                      min,
                      entry.peakPosition ?? CONSTANTS.DEFAULT_PEAK_VALUE
                    ),
                  CONSTANTS.DEFAULT_PEAK_VALUE
                ) ?? CONSTANTS.DEFAULT_PEAK_VALUE;
              const peakEntry = trackData.history?.find(
                (entry) => entry.rank === overallPeak
              );
              const peakWeekDate = peakEntry?.week;

              artistTracks.push({
                key: trackKey,
                name: trackData.trackName || 'Unknown Track',
                totalPlays: trackData.totalPlays || 0,
                peak:
                  overallPeak <= CONSTANTS.MAX_LIST_ITEMS ? overallPeak : null,
                peakWeek: peakWeekDate,
              });
            }
          });

          if (artistTracks.length === 0) return; // No tracks found for this artist

          // Sort artist's tracks: primarily by peak position (lower is better), then by total plays (higher is better)
          artistTracks.sort((a, b) => {
            const peakA =
              a.peak === null ? CONSTANTS.DEFAULT_PEAK_VALUE : a.peak;
            const peakB =
              b.peak === null ? CONSTANTS.DEFAULT_PEAK_VALUE : b.peak;
            if (peakA !== peakB) {
              return peakA - peakB; // Sort by peak ascending
            }
            return b.totalPlays - a.totalPlays; // Sort by plays descending as tie-breaker
          });

          const topNTracks = artistTracks.slice(0, 10); // Display top 10

          let listHTML = `<h4>Top ${topNTracks.length} Tracks for ${displayArtistName} (by Peak, then Plays):</h4>`;
          topNTracks.forEach((track, index) => {
            const peakDisplay = track.peak !== null ? track.peak : '-';
            const peakWeekDateKey = formatDateKey(track.peakWeek);
            // Make peak week date clickable
            const peakWeekDisplayHTML = peakWeekDateKey
              ? `<span class="clickable-week-date" data-date="${peakWeekDateKey}">${formatDisplayDate(
                  track.peakWeek
                )}</span>`
              : formatDisplayDate(track.peakWeek); // Handles N/A case

            listHTML += `
                <div class="artist-song-item">
                    <div class="artist-song-rank">${index + 1}.</div>
                    <div>
                        <span class="artist-song-name" data-track-key="${
                          track.key
                        }">${track.name}</span>
                        <div class="artist-song-plays">(${
                          track.totalPlays
                        } Plays)</div>
                    </div>
                    <div class="artist-song-peak-info">Peak: ${peakDisplay} (${peakWeekDisplayHTML})</div>
                </div>
            `;
          });

          artistTopSongsContainer.innerHTML = listHTML;
          artistTopSongsContainer.style.display = 'block'; // Show the list
        }

        // --- Export Image Functionality ---

        /** Initiates the export process: prepares data, preloads images, shows preview modal */
        async function handleExportImageClick() {
          if (!html2canvas) {
            updateStatus(
              'Error: Image export library (html2canvas) not loaded.',
              true
            );
            return;
          }
          if (selectedHistoryEntity.key) {
            updateStatus(
              'Export is only available from the Top 100 list view.',
              true
            );
            return;
          }
          if (!processedData.allWeeks || processedData.allWeeks.length === 0) {
            updateStatus('No data loaded to export.', true);
            return;
          }

          const originalButtonText = exportImageBtn.textContent;
          exportImageBtn.disabled = true;
          exportImageBtn.textContent = 'Generating Preview...';
          updateStatus('Preparing export data and preloading images...');

          try {
            const currentEntityType = entityTypeSelect.value;
            const dataMap =
              currentEntityType === 'track'
                ? processedData.tracks
                : processedData.artists;
            const displayWeekIndex =
              currentWeekIndex === -1
                ? processedData.allWeeks.length - 1
                : currentWeekIndex;
            const displayWeekDate = processedData.allWeeks[displayWeekIndex];
            const displayWeekKey = formatDateKey(displayWeekDate);

            if (!displayWeekKey)
              throw new Error('Cannot determine current week for export.');

            const listData = prepareTop100ListData(
              currentEntityType,
              dataMap,
              displayWeekKey
            );
            const topNData = listData.slice(0, exportCountN); // Get only the top N items

            // Preload images for the top N items to embed them in the canvas
            const imageResults = await preloadImages(topNData);
            console.log('Image preload results:', imageResults);

            updateStatus('Generating HTML preview...');
            const exportTitle = `Top ${exportCountN} ${currentEntityType}s - Week of ${displayWeekKey}`;
            const exportContentHTML = renderExportListHTML(
              topNData,
              exportTitle,
              imageResults
            );

            // Store filename for later use
            tempExportFilename = `top${exportCountN}-${currentEntityType}-chart-${displayWeekKey}.png`;

            // Display the preview in the modal
            if (previewContentWrapper && exportPreviewModal) {
              previewContentWrapper.innerHTML = exportContentHTML;
              exportPreviewModal.style.display = 'flex'; // Show modal
              updateStatus(
                'Preview ready. Confirm to generate image and download.'
              );
            } else {
              console.error('Export preview modal elements not found!');
              updateStatus(
                'Error showing preview. Attempting direct download.',
                true
              );
              // Fallback: try to generate and download directly if modal fails
              await generateAndDownloadCanvas(
                exportContentHTML,
                tempExportFilename
              );
            }
          } catch (err) {
            console.error('Error during export preparation:', err);
            updateStatus(
              `Error preparing export: ${err.message}. See console.`,
              true
            );
          } finally {
            // Restore button state only after async operations complete
            exportImageBtn.disabled = false;
            exportImageBtn.textContent = originalButtonText;
          }
        }

        /** Preloads images used in the export list */
        async function preloadImages(listData) {
          const promises = [];
          const imageMap = new Map(); // key -> { success: bool, element: Image | null }

          listData.forEach((item) => {
            if (item.albumMbid && entityTypeSelect.value === 'track') {
              const promise = new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous'; // Needed for canvas tainting rules
                img.onload = () =>
                  resolve({ key: item.key, success: true, element: img });
                img.onerror = (e) => {
                  console.warn(
                    `Failed to load image for ${item.name} (MBID: ${item.albumMbid}):`,
                    e
                  );
                  resolve({ key: item.key, success: false, element: null });
                };
                img.src = `https://coverartarchive.org/release/${item.albumMbid}/front-250`;
              });
              promises.push(promise);
            } else {
              // No image URL available, mark as failed immediately
              imageMap.set(item.key, { success: false, element: null });
            }
          });

          // Wait for all image loading attempts to settle (resolve or reject)
          const results = await Promise.allSettled(promises);

          results.forEach((result) => {
            if (result.status === 'fulfilled' && result.value) {
              imageMap.set(result.value.key, {
                success: result.value.success,
                element: result.value.element,
              });
            } else if (result.status === 'rejected') {
              // Should ideally not happen with the Promise structure above, but log if it does
              console.error(
                'Image preload promise unexpectedly rejected:',
                result.reason
              );
            }
          });

          return imageMap;
        }

        /** Closes the export preview modal */
        function closeExportModal() {
          if (exportPreviewModal) {
            exportPreviewModal.style.display = 'none';
            if (previewContentWrapper) previewContentWrapper.innerHTML = ''; // Clear content
            tempExportFilename = ''; // Clear stored filename
          }
        }

        /** Handles the confirmation click: generates canvas from preview and triggers download */
        async function confirmAndDownloadExport() {
          const htmlToExport = previewContentWrapper?.innerHTML; // Get HTML from the preview
          const filename = tempExportFilename;

          if (!htmlToExport || !filename) {
            updateStatus(
              'Error: Export data missing. Cannot generate image.',
              true
            );
            closeExportModal();
            return;
          }

          confirmExportBtn.disabled = true;
          confirmExportBtn.textContent = 'Generating Image...';
          updateStatus(
            'Generating image from preview (this might take a moment)...'
          );

          try {
            await generateAndDownloadCanvas(htmlToExport, filename);
            updateStatus('Image exported successfully.');
          } catch (err) {
            console.error('Error generating or downloading canvas:', err);
            updateStatus(
              `Error exporting image: ${err.message}. See console.`,
              true
            );
          } finally {
            confirmExportBtn.disabled = false;
            confirmExportBtn.textContent = 'Generate Image & Download';
            closeExportModal(); // Close modal regardless of success/failure
          }
        }

        /** Creates an off-screen container, renders HTML to canvas, and triggers download */
        async function generateAndDownloadCanvas(htmlContent, filename) {
          // Create a temporary, off-screen container for rendering
          let tempContainer = document.getElementById(
            CONSTANTS.EXPORT_CONTAINER_ID
          );
          if (tempContainer) tempContainer.remove(); // Remove if exists from previous attempt

          tempContainer = document.createElement('div');
          tempContainer.id = CONSTANTS.EXPORT_CONTAINER_ID;
          // Apply necessary styles for html2canvas to render correctly
          Object.assign(tempContainer.style, {
            position: 'absolute',
            left: '-9999px', // Position off-screen
            top: 'auto',
            width: `${CONSTANTS.EXPORT_IMAGE_WIDTH}px`,
            background: CONSTANTS.EXPORT_BG_GRADIENT,
            padding: '40px',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'flex-start',
            minHeight: '1px', // Avoid potential zero-height issues
            // Inherit fonts, etc., or set explicitly if needed
            fontFamily: "'Inter', sans-serif",
            fontSize: '14px', // Match CSS for consistency
          });
          tempContainer.innerHTML = htmlContent; // Inject the previewed HTML
          document.body.appendChild(tempContainer);

          try {
            // Brief pause to allow browser rendering, especially for images
            await new Promise((resolve) =>
              setTimeout(resolve, CONSTANTS.EXPORT_PRELOAD_TIMEOUT)
            );

            const canvas = await html2canvas(tempContainer, {
              backgroundColor: null, // Use container's background gradient
              useCORS: true, // Important for external images (like Cover Art Archive)
              logging: false, // Disable html2canvas console logs
              scale: window.devicePixelRatio * 1.5, // Increase scale slightly for better resolution
            });

            // Trigger download
            const imageURL = canvas.toDataURL('image/png');
            const downloadLink = document.createElement('a');
            downloadLink.download = filename;
            downloadLink.href = imageURL;
            document.body.appendChild(downloadLink); // Required for Firefox
            downloadLink.click();
            document.body.removeChild(downloadLink);
          } finally {
            // Clean up the temporary container
            if (tempContainer) tempContainer.remove();
          }
        }

        /** Renders the HTML structure for the export image content */
        function renderExportListHTML(listData, title, imageResults) {
          let html = `<h3>${title}</h3>`;
          // Header Row
          html += `
            <div class="export-grid-header">
                <div>Rank</div>
                <div>Art</div>
                <div>+/-</div>
                <div style="text-align: left;">Song</div>
                <div>Points</div>
                <div>% Δ</div> <div>Peak</div>
                <div>WoC</div>
            </div>
        `;

          if (!listData || listData.length === 0) {
            html +=
              '<div style="text-align: center; padding: 10px; background-color: white; border-radius: 0 0 8px 8px;">No ranking data available.</div>';
            return html;
          }

          // Data Rows
          listData.forEach((item, index) => {
            const rowBgColor = getExportRowBackgroundColor(
              item.status,
              item.playPercentChange
            );
            const { rankChangeHTML, rankChangeStyle } = getExportRankChangeHTML(
              item.status
            );
            const playChangeText = getExportPlayChangeText(
              item.status,
              item.playPercentChange
            );
            const imageCellHTML = getExportImageCellHTML(
              item,
              imageResults.get(item.key)
            );

            const peakDisplay = item.peak ?? '-';
            const weeksDisplay = item.weeksOnChart ?? '-';
            const pointsDisplay = item.plays ?? '-'; // 'Plays' are used as points here
            const isLastRow = index === listData.length - 1;
            const rowStyle = `background-color: ${rowBgColor}; ${
              isLastRow ? 'border-radius: 0 0 8px 8px;' : ''
            }`;

            html += `
            <div class="export-grid-row" style="${rowStyle}">
                <div class="list-rank">${item.rank}</div>
                <div>${imageCellHTML}</div>
                <div class="list-change" style="${rankChangeStyle}">${rankChangeHTML}</div>
                <div>
                    <span class="list-name">${item.name}</span>
                    ${
                      item.artistName
                        ? `<span class="list-artist">${item.artistName}</span>`
                        : ''
                    }
                </div>
                <div>${pointsDisplay}</div>
                <div>${playChangeText}</div>
                <div>${peakDisplay}</div>
                <div>${weeksDisplay}</div>
            </div>
        `;
          });

          return html;
        }

        // --- Export HTML Rendering Helpers ---

        /** Determines background color for export row based on status/play change */
        function getExportRowBackgroundColor(status, playPercentChange) {
          if (status === 'NEW' || status === 'RE-ENTRY') {
            return CONSTANTS.EXPORT_ROW_BG_NEW;
          }
          if (
            typeof playPercentChange === 'number' &&
            playPercentChange !== Infinity &&
            playPercentChange !== 0
          ) {
            const absChange = Math.abs(playPercentChange);
            // Scale factor based on % change, capped at MAX_PLAY_CHANGE_FACTOR (e.g., 1.0 for 100% change)
            const factor = Math.min(
              absChange / 100,
              CONSTANTS.EXPORT_MAX_PLAY_CHANGE_FACTOR
            );

            if (playPercentChange > 0) {
              return interpolateColor(
                CONSTANTS.EXPORT_ROW_BG_BASE,
                CONSTANTS.EXPORT_ROW_BG_POSITIVE,
                factor
              );
            } else {
              // playPercentChange < 0
              return interpolateColor(
                CONSTANTS.EXPORT_ROW_BG_BASE,
                CONSTANTS.EXPORT_ROW_BG_NEGATIVE,
                factor
              );
            }
          }
          return CONSTANTS.EXPORT_ROW_BG_BASE; // Default white
        }

        /** Generates HTML and style for the rank change column in export */
        function getExportRankChangeHTML(status) {
          let rankChangeHTML = '-';
          let rankChangeStyle = 'color: #6b7280;'; // Default gray

          if (status === 'NEW') {
            rankChangeHTML = 'NEW';
            rankChangeStyle = 'color: #a855f7; font-weight: bold;'; // Purple bold
          } else if (status === 'RE-ENTRY') {
            rankChangeHTML = 'RE';
            rankChangeStyle = 'color: #a855f7; font-weight: bold;'; // Purple bold
          } else if (typeof status === 'number') {
            if (status > 0) {
              // Rank improved (lower number)
              rankChangeHTML = `+${status}`;
              rankChangeStyle = 'color: #10b981;'; // Green
            } else if (status < 0) {
              // Rank worsened (higher number)
              rankChangeHTML = `${status}`; // Already negative
              rankChangeStyle = 'color: #ef4444;'; // Red
            } else {
              // status === 0
              rankChangeHTML = '=';
              rankChangeStyle = 'color: #6b7280;'; // Gray
            }
          }
          return { rankChangeHTML, rankChangeStyle };
        }

        /** Generates text for the play percentage change column in export */
        function getExportPlayChangeText(status, playPercentChange) {
          if (status === 'NEW' || status === 'RE-ENTRY') {
            return status; // Show NEW or RE instead of percentage
          }
          if (typeof playPercentChange === 'number') {
            if (playPercentChange === Infinity) return '++%'; // Large increase from 0
            if (playPercentChange === 0) return '=';
            // Format with sign and percentage symbol
            return `${
              playPercentChange > 0 ? '+' : ''
            }${playPercentChange.toFixed(0)}%`;
          }
          return '-'; // Default if no change data
        }

        /** Generates HTML for the image cell in the export list */
        function getExportImageCellHTML(item, imgResult) {
          if (imgResult && imgResult.success && imgResult.element) {
            // Use the preloaded image element's src
            return `<div class="list-image-container"><img src="${imgResult.element.src}" alt="Cover Art"></div>`;
          } else {
            // Fallback to placeholder if preload failed or no image available
            let initials = '?';
            if (item.name && item.name !== '-') {
              initials = item.name.charAt(0).toUpperCase();
              if (item.artistName && entityTypeSelect.value === 'track') {
                // Check type again for context
                initials += item.artistName.charAt(0).toUpperCase();
              } else if (
                entityTypeSelect.value === 'artist' &&
                item.name.length > 1
              ) {
                initials = item.name.substring(0, 2).toUpperCase();
              }
            }
            return `<div class="list-image-container"><div class="list-image-placeholder">${initials}</div></div>`;
          }
        }
      }); // End of DOMContentLoaded listener
    </script>
  </body>
</html>
